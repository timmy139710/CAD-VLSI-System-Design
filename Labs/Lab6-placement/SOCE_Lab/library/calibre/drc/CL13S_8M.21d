//**************************************************************************************
//* CALIBRE DRC COMMAND FILE - CL13S_8M.21d (VER 2.1d, 11/30/2004)	
//* FOR TSMC 0.13UM LOGIC 1P8M SALICIDE 1.0V/2.5V,1.2V/2.5V,1.0V/3.3V,1.2V/3.3V PROCESS 
//* (DESIGN RULE DOCUMENT: T-013-LO-DR-001 Rev 2.1)
//**************************************************************************************

//
// DISCLAIMER
//
// The information contained herein is provided by TSMC on an "AS IS" basis
// without any warranty, and TSMC has no obligation to support or otherwise
// maintain the information.  TSMC disclaims any representation that the
// information does not infringe any intellectual property rights or proprietary
// rights of any third parties.  There are no other warranties given by TSMC,
// whether express, implied or statutory, including, without limitation, implied
// warranties of merchantability and fitness for a particular purpose.
//
// STATEMENT OF USE
//
// This information contains confidential and proprietary information of TSMC.
// No part of this information may be reproduced, transmitted, transcribed,
// stored in a retrieval system, or translated into any human or computer
// language, in any form or by any means, electronic, mechanical, magnetic,
// optical, chemical, manual, or otherwise, without the prior written permission
// of TSMC.  This information was prepared for informational purpose and is for
// use by TSMC's customers only.  TSMC reserves the right to make changes in the
// information at any time and without notice.
//
//**************************************************************************************
// The older revision history has been moved to the file "Rev_history.txt".
// Revision history of this version.
//  03/12/2004 - Ver 2.1a - Y.T Pu
//      1) Add RDL rules checking in this DRC deck.
//      2) Add four rules: OD2.W.1, DNW.S.3, DNW.S.4 and RPO.A.2.
//  Relaxation:
//      1) Modify the checking of the rule NT_N.S.2 from OD to active OD.    
//	2) Relaxed the checking of the rule LUP.3.
//      3) Move the rules DOD.S.4, DPO.S.4, DMx.S.5 to Recommended.
//      4) Remove the notch checking of Nwell in same polygon(NW.S.2 and NW.S.4).
//      5) Remove four rules: VTH_N.R.2, VTH_P.R.2, VTL_P.R.2, VTL_N.R.2.
//  Enhancement:    
//      1) Modify the checking algorithm of all logical operation rules.
//      2) Mx.EN.2: Optimize it for run time. 
//	3) VIAx.R.2: Optimize it for run time.
//  03/22/2004 - Ver 2.1a.1 - Y.T Pu
//  Enhancement:
//      1) Rule DNW.O.1 added checking abut ==0 edge.
//      2) Modify DNW.S.2 to build connection for checking.    
//
//  04/27/2004 - Ver 2.1b
//	1) Change INTERACT to be AND in the space rules of dummy pattern
//  Relaxation:
//      2) Modify the rule LUP.3's checking consider a anti-type region without contact
//         but butted with active region which embeded contact on it to be considered a legal tap.
//      3) Modify the rule ESD.26 checking: Include checking the contact which in RPO hole to 
//         space to the poly edge of NMOS.
//  05/13/2004 - Ver 2.1b.1
//      1) Modify the chip size checking from 50mm^2 to 60mm^2 for the CUP option.
//  Enhancement  
//      2) Add OD without IMP checking in PP.EN.2 when OD outside NW resistor, LOGO and CDUDMY.
//  05/19/2004 - Ver 2.1b.2
//      1) Followed the value changing of the CUP DRM for 0.13um process:
//         The empty region value has been changed from 155.5 to 157.
//  05/25/2004 - Ver 2.1b.3
//  Enhancement
//      1) Modify the checking methodology of the rule Mx.S.2 for checking exactly.
//  06/14/2004 - Ver 2.1c
//  Enhancement:
//      1) Modify the check of the rule PP.EN.1 for all poly(including PO resistor).
//  Relaxation:
//      2) Modify the check of the rule PP.EN.2 for excluding the checking of OD w/o implant from SRAM.
//      3) Modify the check of the rules N/PP.S.7, N/PP.EX.3 for unsilicide device only.
//  11/30/2004 - Ver 2.1d
//      1) Adding "LAYOUT BASE LAYER" in this DRC deck.  
//      2) Changing the check methodology of G.3.
//  Enhencement:    
//      3) Modifying the derive layer "NRODi" for including ESD MOS in the LUP.3N/P checks.
//  Relaxation:
//      4) Shrinking the empty region when turn on the option "CUP".
//      5) Modifying the density check methodology of OD and Metalx. 
//      6) Modify the check of the rule DNW.R.1 for excluding the check from DNW inside of VARDMY.  
//******************************************************************************************

//***********************************************************************************
//  RULES/GUIDELINES NOT IMPLEMENTED:
//***********************************************************************************
//
//  1. Reversed bias between NW(interact with DNW) and PW: DNW.R.2  
//  2. Part of NT_N.I.3: unable to identify NMOS capacitors with same potential.
//  3. Poly line-end must be rectangular: PO.R.2
//  4. OD/Poly Resistor Guidelines
//  5. Recommendation for Redundant Via
//  6. Metal slot should be parallel to current flow: MS.R.2
//  7. Current Density (EM) Specification
//  8. Part of LOGO.R.2: Circuit in LOGO is not allowed, only check layers straddling boundary 
//  9. Chip Corner Stress Relief Pattern: 
//	CSR.EN.1, CSR.EN.2, CSR.EN.3, CSR.R.4
//  10. Seal-Ring Rule: only partial structures are checked.
//  11. SRAM Rule
//  12. Part of DOD.R.1: DOD CAD layer must be different from OD's
//  13. Part of DPO.R.1: DPO CAD layer must be different from PO's
//  14. Part of DMx.R.1: DMx CAD layer must be different from Mx's
//  15. Rules in Recommendation Rule Summary section
//  16. Layout Guideline for Analog Circuit
//  17. Layout Guideline for Latch-up: LUP.1, LUP.4-9
//  18. I/O ESD Protection Guideline:
//	ESD.1, ESD.3-8, ESD.10-15, ESD.21, ESD.27-37
//
//***********************************************************************************


//***********************************************************************************
//  DRC RELEATED LAYERS:  
//***********************************************************************************
//
//  1. PMDMY (Dummy layer to cover metal fuse protection ring for DRC)
//	Please refer to Doc.: T-013-LO-DR-007 and T-013-LO-DR-013
//
//  2. HOTWL (Hot NW dummy layer for DRC)
//	NW not connected to the most positive voltage Vdd is defined as Hot NW. 
//	It must follow different width and space rules from the NW connected to Vdd (Cold NW). 
//	Use "HOTWL" layer to exactly cover the Hot NW area for correct DRC.
//
//  3. NWDMY (NW resistor dummy layer for DRC and LVS)
//	The N-Well region covered by both NWDMY and RPO is the NW within OD resistor.
//	The N-Well region covered by only NWDMY is the NW under STI resistor.
//
//  4. RHDMY (For OD, PO resistors)
//	Please refer to OD/PO resistor guideline
//
//  5. DMSRM (Dummy layer DMSRM should be provided to cover the SRAM cell array)
//	This layer could prevent layers below VIA1 in the covered regions from DRC checks.
//	Please align the boundary of DMSRM and EXCL (if drawn) exactly then the DRC false 
//	errors caused by the boundary effect will not be present.
//	      
//  6. SRAMDMY (SRAM DRC violation waived layer)
//	Layers under VIA1 covered by this layer are DRC waived. In DRC deck, both DMSRM 
//	and SRAMDMY can waive SRAM DRC violation under VIA1. If DMSRM is not in SRAM library, 
//	please use SRAMDMY to waive SRAM DRC violation under VIA1. 
//
//  7. HVTSRM (Dummy layer HVTSRM should be provided to cover the high VT SRAM cell array)
//	HVTSRM edge should be aligned to the boundary of cell array, which may include 
//	storage, strapping, and dummy edge cells. HVTSRM is used to generate VTH_N and 
//	VTH_P masks. HVTSRM should follow the PP or NP implant rules to the patterns 
//	outside of the region covered by HVTSRM. 
//
//  8. LMARK (Dummy layer for laser repairing alignment mark opening)
//	Please refer to Doc.: T-013-LO-DR-007 and T-013-LO-DR-013 (Fuse rule) for detail.
//
//  9. VARDMY (Dummy layer for both MOS and junction type varactor)
//	Please refer to Doc.: T-013-MM-DR-001 for detail.
//
//  10. ESD1DMY (For RPO rule check in ESD device)
//	Please refer to I/O ESD Protection Circuit Design and Layout Guideline.
//
//  11. ESD2DMY (For RPO rule check in ESD device)
//	Please refer to I/O ESD Protection Circuit Design and Layout Guideline.
//
//  12. ESD3DMY (For RPO rule check in ESD device)
//	Please refer to I/O ESD Protection Circuit Design and Layout Guideline.
//
//  13. SEALRING (Dummy layer for seal ring and metal fuse structures)
//	Layer SEALRING should be provided to cover the 
//	seal ring region and metal fuse protection ring region.
//
//  14. CSRDMY (For stress relief pattern rule check)
//
//  15. CDUDMY (Dummy layer CDUDMY should be provided to cover CDU patterns)
//	CDUDMY should be provided to cover CDU pattern in 10um assembly isolation 
//	beside seal ring.
//
//  16. LOGO (LOGO and product labels layer for DRC)
//
//  17. ODBLK (Dummy OD exclusive region for insertion utility)
//
//  18. POBLK (Dummy PO exclusive region for insertion utility)
//
//  19. DMxEXCL (Dummy Mx exclusive region for insertion utility)
//
//  20. SDI (SDI is a required DRC dummy layer to check I/O ESD and latch-up guidelines) 
//	Cover SDI layer on all I/O MOS (OD) regions, which are connected to pads.
//
//  21. INDDMY (Dummy layer for inductor)
//	Please refer to Doc.: T-013-MM-DR-001 for detail.
//
//  22. EXCL (DRC excluding area)
//	If there's any area with different rules and not to be checked in this run, 
//	use the EXCL layer to exactly cover the area to be excluded.
//
//***********************************************************************************
// 	CORRECT USAGE:
//***********************************************************************************
//
// * Calibre v9.3_6.5 (Dec, 2003) was used to develop and QA this command file. 
//
// * To correctly use this DRC deck, the following settings are very important in
//    this DRC command file:
//	
//  (1) HIGH_VOLTAGE variable: (default is "3.3V")
//	There must be at least one and only one of the high voltage variables defined!
//	The default of this DRC command file assumes 3.3V is used as high voltage.
//	If other high voltages are used, please DEFINE other variables. For example,
//  	if 2.5V is used as high voltage, then the settings should be:
//		//#DEFINE 3.3V 	// when HIGH_VOLTAGE = 3.3V
//		#DEFINE 2.5V 	// when HIGH_VOLTAGE = 2.5V
//		//#DEFINE 1.8V 	// when HIGH_VOLTAGE = 1.8V
//
//  (2) FULL_CHIP variable: (default is on)
//	By default this variable is on and chip corner/sealring (CSR.R.1) is considered. 
//	Turn on this switch even if customer requests TSMC to add chip corner stress relief 
//	patterns. Please comment out the following line if you are running on a cell or macro:
//		#DEFINE FULL_CHIP
//
//	This variable also affects rules for CDU patterns, and densities. More details,  
//	please refer to the section "Chip Corner Stress Relief Pattern and Seal-Ring Rule" 
//	in design rule manual.
//
//  (3) BigDieChipCorner variable: (default is on)
//	If customer requests TSMC to add chip corner stress relief pattern, seal ring and CDU,
//	empty areas in 4 chip corners must be reserved and no layout is allowed inside. When 
//	chip size > 50mm^2 there must be added big die pattern; if chip size <= 50mm^2 
//	it could be added either small or big die pattern.
//	By default, this variable is enabled and assume customers use big die pattern  
//	(pentagon) for small size chip. Please disable this definition if the size of your 
//	chip is <= 50mm^2 and you desire the triangle shape die corner pattern.
//
//  (4) GUIDELINE variable: (default is off)
//	Guidelines are not checked by default. But enable GUIDELINE option to check the rules
//	of guidelines are stronly suggested.
//	Please #DEFINE GUIDELINE if you want to check guidelines by using
//		#DEFINE GUIDELINE
//
//	Currently LDN(P).EX.3, LDN(P).EX.4, VT.S.1-4, VT.EX.1-3, and
//	ESD guidelines are included.
//
//  (5) SUGGESTED variable: (default is off)
//	Suggestions are not checked by default. Please #DEFINE SUGGESTED if you want 
//	to check recommendations by using
// 		#DEFINE SUGGESTED
//    Notice:
//	Turn on this option may cause SERIOUS performance issue and generate tremendous error 
//	counts! Please consider the suggested rules at the early developing stage of IC 
//	layout to avoid the above issues. Following these rules will help the qality of process 
//	yielding. Currently the following checks are included in SUGGESTED checks:
//	(A) SUGGESTED.NW.S.3
//	    A conservative way to check NW.S.3: since DRC has no way to know the operating 
//	    voltage of NW1V and NW2V, only geometrical patterns and connectivity information 
//	    are considered. If NW1V might be operating in high voltage, it is better to 
//	    turn on this check.
//	(B) SUGGESTED.OD.IMP 
//	    OD without implantation is not allowed.
//	(C) SUGGESTED.MS.Mx
//	    Long (>200um) and narrow (<3um) slots are not recommended.
//
//  (6) SRAMDMY_USED_ONLY variable: (default is off)
//      By default, DRC does not check layers(only below Metal2) inside SRAM region covered  
//      by DMSRM(50) and SRAMDMY(186;0). Customers could enable this option and use only
//	SRAMDMY layer to exclude DRC for SRAM regions. Please notice that turn on this option 
//	will also disable the function of EXCL, and the region covered by EXCL will be
//	examined with entire rules.
//	Please un-comment the line below to enable this function:
// 		#DEFINE SRAMDMY_USED_ONLY
//
//  (7) CHECK_DENSITY_IN_ODBLK variable: (default is off)
//	OD density rules (OD.DN.1, OD.DN.2, OD.DN.3, OD.DN.4) do not check the region of 
//	ODBLK by default. For better process/electronical performance, customer could also 
//	adds the dummy OD patterns inside ODBLK regions manually. Turn on this variable could 
//	help on checking the uniformity of the OD insertion inside ODBLK regions.
//	Please refer to the line below if you want to check recommendations by using
// 		#DEFINE CHECK_DENSITY_IN_ODBLK
//
//  (8) CHECK_DENSITY_IN_DMxEXCL_ONLY: (default is off)
//	By default, metal density checks will include the DMxEXCL regions even these regions
//	are blocked during the dummy metal insertion.
//	If customers fill the dummy metal by their own method, the metal density inside the 
//	DMxEXCL regions should still meet the requirement of the density rules.
//	If customers use TSMC formal utility to insert the dummy patterns, the density 
//	violations outside the DMxEXCL regions could be waived. But the density violations 
//	inside the DMxEXCL regions are still need to be reviewed by TSMC.
//	Please turn on this option as following after TSMC's formal utilities are executed and 
//	output the violations only inside the DMxEXCL regions to be reviewed:
// 		#DEFINE CHECK_DENSITY_IN_DMxEXCL_ONLY
//
//
//  (9) THICK_TOP2_METAL and THICK_TOP3_METAL variables: (default is off)
//	By default, both of these variables are turned off, and there will be only one top metal
//	(Metal8) assumed to be thick. If customers have more than one tick metals on the top,
//	please turned these definitions of variable on(remove the comment marks). 
//	When only M7 and M8 are thick metal:
//		#DEFINE THICK_TOP2_METAL	// when M7 is thick metal
//
//	When M6, M7 and M8 are thick metal:
//		#DEFINE THICK_TOP3_METAL	// when M6 and M7 are thick metal
//
//	(The THICK_TOP2_METAL will also be turned on automatically if THICK_TOP3_METAL was
//	 switched on.)
//	After turn on one or both of the variables, the corresponded thick metals and the VIAs
//	above normal metals will be forced to checked with the rules of "M8" and "VIA7" that
//	described in  logic DRM.
//
// (10) CUP variable: (default is off)
//	If the CUP (Circuit Under Pad) structure is used as the design, please un-comment the
//	line as follow to apply proper slot checks:
//		#DEFINE CUP
//
//***********************************************************************************
// 	OPTIONAL SEETINGS FOR CALIBRE:
//***********************************************************************************
//
//DRC INCREMENTAL CONNECT YES
//DRC EXCLUDE FALSE NOTCH YES   // Please enable this line to fix violations caused by
				// FALSE NOTCH feature. But the DRC runtime will increase.
//LAYOUT ALLOW DUPLICATE CELL YES

#DEFINE 3.3V 	// when HIGH_VOLTAGE = 3.3V
//#DEFINE 2.5V 	// when HIGH_VOLTAGE = 2.5V
//#DEFINE 1.8V 	// when HIGH_VOLTAGE = 1.8V

#DEFINE FULL_CHIP 		// when chip corner/sealring is considered
#DEFINE BigDieChipCorner 	// when pentagon shape corner is wanted for small size chip

//#DEFINE GUIDELINE 		// when you want to check ESD guideline
//#DEFINE SUGGESTED 		// when you want to check suggested rule

//#DEFINE SRAMDMY_USED_ONLY	// replace EXCL and DMSRM with LOGO and SRAM_DUMMY layers
//#DEFINE CHECK_DENSITY_IN_ODBLK // include the ODBLK region to be checked with OD density rules
//#DEFINE CHECK_DENSITY_IN_DMxEXCL_ONLY	// check metal density only inside the DMxEXCL regions


//#DEFINE THICK_TOP2_METAL	// when M7 and M8 are thick metal
//#DEFINE THICK_TOP3_METAL	// when M6, M7 and M8 are thick metal

//#DEFINE CUP			// when CUP (Circuit Under Pad) structure is used




// ENVIRONMENT SETUP
//------------------

PRECISION    1000
RESOLUTION      5    // Layout grid is 0.005um

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep" // HIER  
DRC CHECK TEXT ALL

FLAG OFFGRID YES  // For layout grid check, default grid space is value of resolution.
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO


VARIABLE  DNW_S_2   3.5 
VARIABLE  MS_R_1_W_s 5.999
VARIABLE  MS_R_1_W   12
VARIABLE  MS_R_1_L   30
VARIABLE  MS_DN_1    0.09
VARIABLE  DOD_W_1   2.0 
VARIABLE  DOD_S_1   1.2 
VARIABLE  DOD_S_2   1.2 
VARIABLE  DOD_S_3   1.2 
VARIABLE  DOD_S_5   0.6 
VARIABLE  DOD_S_6   1.2 
VARIABLE  DOD_S_7   1.2 
VARIABLE  DOD_S_8   1.2 
VARIABLE  DOD_S_10   1.2 
VARIABLE  DOD_EN_1   0.6 
VARIABLE  DOD_EN_2   2.5 

VARIABLE  DPO_W_1   0.6 
VARIABLE  DPO_S_1   0.3 
VARIABLE  DPO_S_2   1.2 
VARIABLE  DPO_S_3   1.2 
VARIABLE  DPO_S_5   1.2 
VARIABLE  DPO_S_6   1.2 
VARIABLE  DPO_S_8   1.2
VARIABLE  DPO_S_9   0.3
VARIABLE  DPO_EN_1  2.5 



// DRAWN LAYER DEFINITIONS
//------------------------

LAYER DNWELLi    1     			// DNWELL deep-nwell
LAYER NWELLi     3      		// NWELL  nwell technology
LAYER DIFFi      6   			// OD/DIFF  diffusion areas
LAYER PDIFFi     7   			// PDIFF diffusion areas
LAYER NDIFFi     8			// NDIFF diffusion areas
LAYER DOD        340    		// Dummy OD (DIFF)
LAYER MAP 6   DATATYPE 1 340  		// Mapping (6;1) to 340 for dummy OD as default
// DOD should be an individual CAD layer and different from real OD
LAYER ODBLK      350    		// DOD and DPO blocking for insertion
LAYER MAP 150 DATATYPE 20 350
LAYER OD2i       15     		// OD2 define thick oxides for HV gates
LAYER POLYGi     17    			// POLYG polysilicon gates, interconnect
LAYER DPO        342   	 		// Dummy Poly
LAYER MAP 17  DATATYPE 1 342  		// Mapping (17;1) to 342 for dummy PO
// DPO should be an individual CAD layer and different from real POLGY
LAYER POBLK      351    		// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 351
LAYER PIMPi      25     		// PIMP P+ imlant
LAYER NIMPi      26     		// NIMP N+ imlant
LAYER CONTi      30     		// CONT Define connect for M1 to S/D and Gate

LAYER METAL1i    31     		// METAL1
LAYER M1SLOTi    321    		// Metal1 slot (if drawn)
LAYER MAP 31  DATATYPE 2 321  		// Mapping (31;2) to 321 for M1SLOTi
LAYER DUM1       331  			// dummy Metal1
LAYER MAP 31  DATATYPE 1 331  		// Mapping (31;1) to 331 for DUM1
LAYER DM1EXCL    371
LAYER MAP 150 DATATYPE 1 371
LAYER METAL2i    32     		// METAL2
LAYER M2SLOTi    322    		// Metal2 slot (if drawn)
LAYER MAP 32  DATATYPE 2 322  		// Mapping (32;2) to 322 for M2SLOTi
LAYER DUM2       332  			// dummy Metal2
LAYER MAP 32  DATATYPE 1 332  		// Mapping (32;1) to 332 for DUM2
LAYER DM2EXCL    372
LAYER MAP 150 DATATYPE 2 372
LAYER METAL3i    33     		// METAL3
LAYER M3SLOTi    323    		// Metal3 slot (if drawn)
LAYER MAP 33  DATATYPE 2 323  		// Mapping (33;2) to 323 for M3SLOTi
LAYER DUM3       333  			// dummy Metal3
LAYER MAP 33  DATATYPE 1 333  		// Mapping (33;1) to 333 for DUM3
LAYER DM3EXCL    373
LAYER MAP 150 DATATYPE 3 373
LAYER METAL4i    34     		// METAL4
LAYER M4SLOTi    324    		// Metal4 slot (if drawn)
LAYER MAP 34  DATATYPE 2 324  		// Mapping (34;2) to 324 for M4SLOTi
LAYER DUM4       334  			// dummy Metal4
LAYER MAP 34  DATATYPE 1 334  		// Mapping (34;1) to 334 for DUM4
LAYER DM4EXCL    374
LAYER MAP 150 DATATYPE 4 374
LAYER METAL5i    35     		// METAL5
LAYER M5SLOTi    325    		// Metal5 slot (if drawn)
LAYER MAP 35  DATATYPE 2 325  		// Mapping (35;2) to 325 for M5SLOTi
LAYER DUM5       335  			// dummy Metal5
LAYER MAP 35  DATATYPE 1 335  		// Mapping (35;1) to 335 for DUM5
LAYER DM5EXCL    375
LAYER MAP 150 DATATYPE 5 375
LAYER METAL6i    36     		// METAL6
LAYER M6SLOTi    326    		// Metal6 slot (if drawn)
LAYER MAP 36  DATATYPE 2 326  		// Mapping (36;2) to 326 for M6SLOTi
LAYER DUM6       336  			// dummy Metal6
LAYER MAP 36  DATATYPE 1 336  		// Mapping (36;1) to 336 for DUM6
LAYER DM6EXCL    376
LAYER MAP 150 DATATYPE 6 376
LAYER METAL7i    37     		// METAL7
LAYER M7SLOTi    327    		// Metal7 slot (if drawn)
LAYER MAP 37  DATATYPE 2 327  		// Mapping (37;2) to 327 for M7SLOTi
LAYER DUM7       337  			// dummy Metal7
LAYER MAP 37  DATATYPE 1 337  		// Mapping (37;1) to 337 for DUM7
LAYER DM7EXCL    377
LAYER MAP 150 DATATYPE 7 377
LAYER METAL8i    38     		// METAL8
LAYER M8SLOTi    328    		// Metal8 slot (if drawn)
LAYER MAP 38  DATATYPE 2 328  		// Mapping (38;2) to 328 for M8SLOTi
LAYER DUM8       338  			// dummy Metal8
LAYER MAP 38  DATATYPE 1 338  		// Mapping (38;1) to 338 for DUM8
LAYER DM8EXCL    378
LAYER MAP 150 DATATYPE 8 378
LAYER METAL9i    39     		// METAL9
LAYER M9SLOTi    329    		// Metal9 slot (if drawn)
LAYER MAP 39  DATATYPE 2 329  		// Mapping (39;2) to 329 for M9SLOTi
LAYER DUM9       339  			// dummy Metal9
LAYER MAP 39  DATATYPE 1 339  		// Mapping (39;1) to 339 for DUM9
LAYER DM9EXCL    379
LAYER MAP 150 DATATYPE 9 379
LAYER MDi        168    		// MD For RDL interconnection
LAYER MDSLOTi    343    		// MD slot (if drawn)
LAYER MAP 168 DATATYPE 2 343  		// Mapping (168;2) to 343 for MDSLOTi
LAYER DUMD       344  			// dummy MD
LAYER MAP 168 DATATYPE 1 344  		// Mapping (168;1) to 344 for DUMD
LAYER DMDEXCL    380
LAYER MAP 150 DATATYPE 15 380

LAYER VIA12i     51     		// VIA12 Define connection from M2 to M1
LAYER VIA23i     52     		// VIA23 Define connection from M3 to M2
LAYER VIA34i     53     		// VIA34 Define connection from M4 to M3
LAYER VIA45i     54     		// VIA45 Define connection from M5 to M4
LAYER VIA56i     55     		// VIA56 Define connection from M6 to M5
LAYER VIA67i     56     		// VIA67 Define connection from M7 to M6
LAYER VIA78i     57     		// VIA78 Define connection from M8 to M7
LAYER VIA89i     58     		// VIA89 Define connection from M9 to M8
LAYER VIADi      167    		// VIAD	Connection between MD and Mtop for RDL

LAYER APi        42
LAYER PADi       43     		// PAD(CB) Passivation opening for Bond Pad
LAYER CB2i       86                     // Passivation 2 for AP RDL used.
LAYER CBDi       169    		// CBD for solder bump and RDL layer (filp-chip design) 
LAYER UBMi       170    		// UBM for solder bump and RDL layer 
LAYER WBDMY      183			// WBDMY for CUP structure recognition

LAYER RPOi       29     		// RPO Silicide blockage layer
LAYER NT_Ni      11     		// NTN Native NMOS implant blockage
LAYER VTL_Ni     12     		// VT1MN 1.2V Low Vt NMOS Implant
LAYER VTL_Pi     13     		// VT1MP 1.2V Low Vt PMOS Implant
LAYER VTH_Ni     67     		// VT2MN 1.0V or 1.2V High Vt NMOS Implant
LAYER VTH_Pi     68     		// VT2MP 1.0V or 1.2V High Vt PMOS Implant
LAYER CTMi       77     		// CTM MiM capacitor
LAYER HRIi       70     		// HRI High resistor implant
LAYER FWi        95     		// FW Fuse passivation window
LAYER PLMIDEi    5      		// PLMIDE Polymide (PM)
LAYER SEALRING   162	 		// SEALRING Layer used seal ring area
LAYER CSRDMY	 166	 		// CSRDMY Layer to cover chip corner areas

// Dummy Layers

LAYER NWDMY      114    		// NWDMY NWEL resistor dummy layer
LAYER HOTWL	 112    		// HOTWL Dummy layer to mark hot-NWELL for DRC 
LAYER RHDMY      117    		// RHDMY Dummy layer for OD/POLY resistoris
LAYER RPDMY      115    		// RPDMY Dummy layer for precision high poly resistor
LAYER PMDMY      106    		// PMDMY Dummy layer for fuse window and protection ring structure
LAYER SDI        122    		// SDI DRC purpose for ESD protection devices
LAYER ESD1DMY    145	 		// ESD1DMY for ESD protection devices
LAYER ESD2DMY    146    		// ESD2DMY for ESD protection devices
LAYER ESD3DMY    147    		// ESD3DMY for ESD protection devices
LAYER LMARK      109    		// LMARK Alignment Mark Rule for Laser Repair
LAYER RHRIDMY    120    		// RHRIDMY Dummy layer for precision HRI poly resistor
LAYER VARDMY     143    		// VARDMY Dummy layer for both MOS and junction type varactor
LAYER LOGO       158  			// Dummy layer for product labels and LOGO
LAYER INDDMY     144    		// INDDMY Dummy layer to cover inductor devices
LAYER CBMi       88       		// Definition of capacitor bottom metal
LAYER CDUDMY     165    		// CDUDMY Dummy layer to cover CDU pattern 
LAYER EXCLi      121    		// EXCL Exclude all layers for DRC except SRAM region
LAYER DMSRMi     50	 		// DMSRM dummy layer to cover SRAM cells to exclude DRC 
			 		// below M2. DRC still checks M2 and above. 
LAYER HVTSRM     60	 		// HVTSRM dummy layer to cover high Vt SRAM cells 
LAYER SRAMDMY    400  			// SRAM DRC violations waive layer
LAYER MAP 186 DATATYPE 0 400 
LAYER CTMDMY     148    		// CTMDMY Dummy layer for MiM capacitor bottom plate

LAYOUT TOP LAYER DOD ODBLK DPO POBLK
LAYOUT TOP LAYER METAL1i M1SLOTi DUM1 DM1EXCL VIA12i
LAYOUT TOP LAYER METAL2i M2SLOTi DUM2 DM2EXCL VIA23i
LAYOUT TOP LAYER METAL3i M3SLOTi DUM3 DM3EXCL VIA34i
LAYOUT TOP LAYER METAL4i M4SLOTi DUM4 DM4EXCL VIA45i
LAYOUT TOP LAYER METAL5i M5SLOTi DUM5 DM5EXCL VIA56i
LAYOUT TOP LAYER METAL6i M6SLOTi DUM6 DM6EXCL VIA67i
LAYOUT TOP LAYER METAL7i M7SLOTi DUM7 DM7EXCL VIA78i
LAYOUT TOP LAYER METAL8i M8SLOTi DUM8 DM8EXCL VIA89i
LAYOUT TOP LAYER METAL9i M9SLOTi DUM9 DM9EXCL
LAYOUT TOP LAYER VIADi MDi MDSLOTi DUMD DMDEXCL CTMi CTMDMY INDDMY
LAYOUT TOP LAYER PADi CBDi UBMi FWi LMARK PLMIDEi SEALRING CSRDMY
LAYOUT TOP LAYER HOTWL EXCLi LOGO DMSRMi HVTSRM
LAYOUT TOP LAYER RHDMY PMDMY SDI ESD1DMY ESD2DMY ESD3DMY
LAYOUT TOP LAYER APi WBDMY CBMi CDUDMY SRAMDMY

ODi      = (DIFFi OR PDIFFi) OR NDIFFi  
ALL_OD   = ODi     OR  DOD  		//For OD density checks
ALL_POLY = POLYGi  OR  DPO

LAYOUT BASE LAYER POLYGi DIFFi PDIFFi NDIFFi CONTi PIMPi NIMPi NWELLi  

// Metal in silicon

M1x = METAL1i NOT M1SLOTi
ALL_M1        = M1x OR DUM1
M2x = METAL2i NOT M2SLOTi
ALL_M2        = M2x OR DUM2
M3x = METAL3i NOT M3SLOTi
ALL_M3        = M3x OR DUM3
M4x = METAL4i NOT M4SLOTi
ALL_M4        = M4x OR DUM4
M5x = METAL5i NOT M5SLOTi
ALL_M5        = M5x OR DUM5
M6x = METAL6i NOT M6SLOTi
ALL_M6        = M6x OR DUM6
M7x = METAL7i NOT M7SLOTi
ALL_M7        = M7x OR DUM7
M8x = METAL8i NOT M8SLOTi
ALL_M8        = M8x OR DUM8
M9x = METAL9i NOT M9SLOTi
ALL_M9        = M9x OR DUM9
MDx = MDi     NOT MDSLOTi
ALL_MD        = MDx OR DUMD

// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------


CHIP         = EXTENT 
//CHIP     = EXTENT CELL "*" ORIGINAL 


BULK       = SIZE CHIP BY 1.0
PWELi 	   = BULK NOT NWELLi

// EXCLUDE UNCHECKED REGIONS
//--------------------------

#IFDEF SRAMDMY_USED_ONLY
  EXCL     = CHIP NOT BULK  // An empty layer to disable the usage of EXCL
  EXCL_SRM = COPY SRAMDMY
#ELSE
  DMSRM    = DMSRMi OR SRAMDMY
  EXCL     = EXCLi  NOT DMSRM
  EXCL_SRM = EXCL   OR DMSRM
#ENDIF

EXCL_SRM_CDUDMY = EXCL_SRM OR CDUDMY 	// exclude the patterns inside the CDU

PWEL    = PWELi   NOT EXCL_SRM
DNW     = DNWELLi NOT INSIDE EXCL_SRM
NWEL    = NWELLi  NOT INSIDE EXCL_SRM
OD      = ODi     NOT EXCL_SRM_CDUDMY
OD2     = OD2i    NOT EXCL_SRM
POLY    = POLYGi  NOT EXCL_SRM_CDUDMY
PP      = PIMPi   NOT INSIDE EXCL_SRM
NP      = NIMPi   NOT INSIDE EXCL_SRM
RPO     = RPOi    NOT EXCL_SRM
NTN     = NT_Ni   NOT EXCL_SRM
VTLN    = VTL_Ni  NOT EXCL_SRM
VTLP    = VTL_Pi  NOT EXCL_SRM
VTHN    = VTH_Ni  NOT EXCL_SRM
VTHP    = VTH_Pi  NOT EXCL_SRM
HRI	= HRIi	  NOT EXCL_SRM
CO      = CONTi   NOT EXCL_SRM_CDUDMY
M1      = M1x     NOT EXCL_SRM_CDUDMY
VIA1    = VIA12i  NOT EXCL_SRM
// M2 and above layers inside DMSRM/SRAMDMY will be checked.
M2      = M2x     NOT INSIDE EXCL
VIA2    = VIA23i  NOT INSIDE EXCL
M3      = M3x     NOT INSIDE EXCL
VIA3    = VIA34i  NOT INSIDE EXCL
M4      = M4x     NOT INSIDE EXCL
VIA4    = VIA45i  NOT INSIDE EXCL
M5      = M5x     NOT INSIDE EXCL
VIA5    = VIA56i  NOT INSIDE EXCL
M6      = M6x     NOT INSIDE EXCL
VIA6    = VIA67i  NOT INSIDE EXCL
M7      = M7x     NOT INSIDE EXCL
VIA7    = VIA78i  NOT INSIDE EXCL
M8      = M8x     NOT INSIDE EXCL
VIA8    = VIA89i  NOT INSIDE EXCL
M9	= M9x     NOT INSIDE EXCL
VIAD    = VIADi   NOT INSIDE EXCL
MD      = MDx     NOT INSIDE EXCL


CB      = PADi    NOT INSIDE EXCL	// CB/PAD for wire bond
CBD     = CBDi    NOT INSIDE EXCL  	// CBD for flip chip
UBM     = UBMi    NOT INSIDE EXCL	// UBM for ground-up
CB2     = CB2i    NOT INSIDE EXCL        

FW      = FWi     NOT INSIDE EXCL
PLMIDE  = PLMIDEi NOT INSIDE EXCL

CTM	= CTMi	  NOT INSIDE EXCL	// Capacitor top metal
CBM     = CBMi    NOT INSIDE EXCL	// Capacitor bottom metal

// Bond Pads

ALL_PAD = PADi    OR  CBDi
RNGX    = PMDMY   NOT FW
VIA_EXD = RNGX    OR  SEALRING			// for line via waiving
// Bonding pad, chip corner dummy pad, and inductor need not put slot

#IFDEF CUP
  SLT_EXD = LMARK OR CSRDMY  			// for CUP design
#ELSE
  SLT_EXD = (LMARK OR CSRDMY) OR PADi  		// for all metal (wire bond)
#ENDIF

FC_NOT   = MDx OR CB2
PAD_EXD  = UBM NOT INTERACT FC_NOT    		// for ground-up 

// For NW checks

RPO_RPDMY  = (RPOi   OR  RPDMY) NOT EXCL_SRM	// for resistor recognition
NRODi      = ODi     NOT RPDMY		
NPODi      = NIMPi   AND NRODi
NONWRi     = NWELLi  NOT INTERACT NWDMY // for NW.S.1/NW.S.2/NW.S.3
NSTPi      = NPODi   AND NONWRi         // NWell pickup 
PPODi      = PIMPi   AND NRODi
PSTPi      = PPODi   NOT NWELLi         // Substrate (pwell) tap diffusion
NACTi      = NPODi   NOT NWELLi         // NMOS device active diffusion including regions of SRAM
PACTi      = PPODi   AND NONWRi		// PMOS 
NSDi       = NACTi   NOT POLYGi         // NMOS source/drain
PSDi       = PACTi   NOT POLYGi		// PMOS source/drain
ILP1i      = POLYGi  NOT RPO_RPDMY	// interconnect poly

NW2V	= NWEL    AND OD2
NW1V	= NWEL    NOT OD2

// For NW (within OD) resistor checks

RNWEL        = NWEL INTERACT NWDMY	// NW resistor (UNDER OD & STI)
NONWR        = NWEL NOT INTERACT NWDMY	// NW exclude resistor area
ODWR         = OD   INTERACT RNWEL	// OD area of NW resistor

IMP          = NP OR  PP
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD		// Contact diffusions 
COPO         = CO NOT OD		// Contacts on poly + floating contacts
//COPO       = POLY AND CO              // POLY contacts + floating contacts

NSTP         = NPOD AND NONWR		// NW strap diffusion
NACT         = NPOD NOT NWEL		// NMOS device active diffusion
PSTP         = PPOD NOT NWEL		// Substrate (pwell) strap diffusion
PACT         = PPOD AND NWEL		// PMOS device active diffusion

DACT         = NACT OR PACT		// NMOS/PMOS device active diffusion
DSTP         = NSTP OR PSTP		// All straps

GATE         = POLY AND OD		// Gate regions for NMOS and PMOS
FPO1         = POLY NOT ODi		// Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2

GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP

GATE_W       = POLY INSIDE EDGE OD     		// Gate width
GATE_L       = OD   INSIDE EDGE POLY   		// Coincident edge of interconnect POLY

GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP

HV_GATE_W    = GATE_W INSIDE EDGE OD2		// 2.5V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2	// 1.2V/1.0V MOS gates
HV_NGATE_W   = HV_GATE_W INSIDE EDGE NP		// 2.5V NMOS gate edges
HV_PGATE_W   = HV_GATE_W INSIDE EDGE PP		// 2.5V PMOS gate edges
LV_NGATE_W   = LV_GATE_W INSIDE EDGE NP		// 1.2V/1.0V NMOS gate edges
LV_PGATE_W   = LV_GATE_W INSIDE EDGE PP		// 1.2V/1.0V PMOS gate edges

// For poly and od resistors identify

RES_NOT_SDI  = RPO_RPDMY NOT SDI 	// For OD/poly resistors
PORES_IN_SDI = (SDI   AND RPO_RPDMY) AND FPO1
PORES_NOT_SDI= RES_NOT_SDI AND FPO1
PORES	     = PORES_IN_SDI OR PORES_NOT_SDI	// POLY resistor region
FOD          = (OD    OUTSIDE NWDMY) OUTSIDE GATE // field oxide
ODRES        = RPO_RPDMY AND FOD 	// OD resistor region
ODPO_RES     = ODRES  OR  PORES		// All OD/poly resitors

// For VTL/H_N/P.R.2 checks

RPO_OD       = RPO AND OD
RPO_PO       = RPO AND POLY

// For ESD checks

PMOS  	     = PACT ENCLOSE GATE
NMOS  	     = NACT ENCLOSE GATE
PASD  	     = PMOS NOT GATE		// Source/Drain of PMOS
NASD  	     = NMOS NOT GATE		// Source/Drain of NMOS
EPMOS 	     = SDI  AND PMOS		// ESD PMOS device
ENMOS 	     = SDI  AND NMOS		// ESD NMOS device

// For SEAL-RING and CHIP CORNER checks.

SR_M1        = (M1x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M2        = (M2x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M3        = (M3x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M4        = (M4x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M5        = (M5x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M6        = (M6x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M7        = (M7x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M8        = (M8x INTERACT SEALRING) NOT INTERACT PMDMY
SR_M9        = (M9x INTERACT SEALRING) NOT INTERACT PMDMY
SR_MD        = (MDx INTERACT SEALRING) NOT INTERACT PMDMY

#IFDEF FULL_CHIP
CHIP_CORE    = SIZE CHIP BY -20		// Width of the seal-ring + assembly isolation
#ELSE
CHIP_CORE    = COPY CHIP
#ENDIF

PADH         = HOLES ALL_PAD
SCORE        = CHIP_CORE INSIDE PADH
SR_EDGE      = (CHIP INTERACT SCORE) NOT SCORE 
CHIP_NOSR    = CHIP  NOT INTERACT SR_EDGE

#IFDEF CUP
SMALL_CHIP   = AREA CHIP_NOSR <= 60000000	// Size <= 60mm square is small chip
BIG_CHIP     = AREA CHIP_NOSR > 60000000
#ELSE
SMALL_CHIP   = AREA CHIP_NOSR <= 50000000	// Size <= 50mm square is small chip
BIG_CHIP     = AREA CHIP_NOSR > 50000000
#ENDIF
CHIP_US      = SIZE CHIP_NOSR BY -157	// Width of chip corner empty region
CHIP_EXP     = EXPAND EDGE CHIP_US OUTSIDE BY 157
CHIP_NO_CORNER = CHIP_US OR CHIP_EXP
CHIP_CORNER  = CHIP_NOSR  NOT CHIP_NO_CORNER

CORNER_TRI   = EXT CHIP_NO_CORNER < 72 ABUT == 90 REGION INTERSECTING ONLY
CORNER_NOT_TRI = CHIP_CORNER NOT CORNER_TRI

// For small chip corner
SMALL_CHIP_CORNER1 = INT SMALL_CHIP < 70.5 ABUT == 90 REGION INTERSECTING ONLY
SMALL_CHIP_CORNER2 = INT SMALL_CHIP < 157 ABUT == 90 REGION INTERSECTING ONLY
#IFDEF CUP
SMALL_CHIP_CORNER = COPY SMALL_CHIP_CORNER1
#ELSE
SMALL_CHIP_CORNER = COPY SMALL_CHIP_CORNER2
#ENDIF

#IFDEF BigDieChipCorner

EMPTY_AREA1  = CORNER_NOT_TRI AND SMALL_CHIP 	// small chip could apply big corner

#ELSE

EMPTY_AREA1  = SMALL_CHIP_CORNER AND SMALL_CHIP

#ENDIF

// For big chip corner

EMPTY_AREA2  = CORNER_NOT_TRI AND BIG_CHIP

EMPTY_AREA     = EMPTY_AREA1    OR EMPTY_AREA2
CHIP_CHAMFERED = CHIP NOT EMPTY_AREA





// Rules of User Guide
//====================

G.1 { @ The design grid must be an integer multiple of 0.005 um. 0.005 um deviation is allowed for 45-degree polygon dimensions.   
  DRAWN OFFGRID
}

G.2.DNWELLi { @ DNWELLi shapes with acute angles between line segments are not allowed.
  INT DNWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWELLi { @ NWELLi shapes with acute angles between line segments are not allowed.
  INT NWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWELLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DIFFi { @ DIFFi shapes with acute angles between line segments are not allowed.
  INT DIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PDIFFi { @ PDIFFi shapes with acute angles between line segments are not allowed.
  INT PDIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PDIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NDIFFi { @ NDIFFi shapes with acute angles between line segments are not allowed.
  INT NDIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NDIFFi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DOD { @ DOD shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODBLK { @ ODBLK shapes with acute angles between line segments are not allowed.
  INT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD2i { @ OD2i shapes with acute angles between line segments are not allowed.
  INT OD2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POLYGi { @ POLYGi shapes with acute angles between line segments are not allowed.
  INT POLYGi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POLYGi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DPO { @ DPO shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POBLK { @ POBLK shapes with acute angles between line segments are not allowed.
  INT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PIMPi { @ PIMPi shapes with acute angles between line segments are not allowed.
  INT PIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NIMPi { @ NIMPi shapes with acute angles between line segments are not allowed.
  INT NIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NIMPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CONTi { @ CONTi shapes with acute angles between line segments are not allowed.
  INT CONTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CONTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL1i { @ METAL1i shapes with acute angles between line segments are not allowed.
  INT METAL1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M1SLOTi { @ M1SLOTi shapes with acute angles between line segments are not allowed.
  INT M1SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM1 { @ DUM1 shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM1EXCL { @ DM1EXCL shapes with acute angles between line segments are not allowed.
  INT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL2i { @ METAL2i shapes with acute angles between line segments are not allowed.
  INT METAL2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M2SLOTi { @ M2SLOTi shapes with acute angles between line segments are not allowed.
  INT M2SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM2 { @ DUM2 shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM2EXCL { @ DM2EXCL shapes with acute angles between line segments are not allowed.
  INT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL3i { @ METAL3i shapes with acute angles between line segments are not allowed.
  INT METAL3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M3SLOTi { @ M3SLOTi shapes with acute angles between line segments are not allowed.
  INT M3SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM3 { @ DUM3 shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM3EXCL { @ DM3EXCL shapes with acute angles between line segments are not allowed.
  INT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL4i { @ METAL4i shapes with acute angles between line segments are not allowed.
  INT METAL4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M4SLOTi { @ M4SLOTi shapes with acute angles between line segments are not allowed.
  INT M4SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM4 { @ DUM4 shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM4EXCL { @ DM4EXCL shapes with acute angles between line segments are not allowed.
  INT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL5i { @ METAL5i shapes with acute angles between line segments are not allowed.
  INT METAL5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M5SLOTi { @ M5SLOTi shapes with acute angles between line segments are not allowed.
  INT M5SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM5 { @ DUM5 shapes with acute angles between line segments are not allowed.
  INT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM5EXCL { @ DM5EXCL shapes with acute angles between line segments are not allowed.
  INT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL6i { @ METAL6i shapes with acute angles between line segments are not allowed.
  INT METAL6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M6SLOTi { @ M6SLOTi shapes with acute angles between line segments are not allowed.
  INT M6SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM6 { @ DUM6 shapes with acute angles between line segments are not allowed.
  INT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM6EXCL { @ DM6EXCL shapes with acute angles between line segments are not allowed.
  INT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL7i { @ METAL7i shapes with acute angles between line segments are not allowed.
  INT METAL7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M7SLOTi { @ M7SLOTi shapes with acute angles between line segments are not allowed.
  INT M7SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM7 { @ DUM7 shapes with acute angles between line segments are not allowed.
  INT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM7EXCL { @ DM7EXCL shapes with acute angles between line segments are not allowed.
  INT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL8i { @ METAL8i shapes with acute angles between line segments are not allowed.
  INT METAL8i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL8i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M8SLOTi { @ M8SLOTi shapes with acute angles between line segments are not allowed.
  INT M8SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM8 { @ DUM8 shapes with acute angles between line segments are not allowed.
  INT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM8EXCL { @ DM8EXCL shapes with acute angles between line segments are not allowed.
  INT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.METAL9i { @ METAL9i shapes with acute angles between line segments are not allowed.
  INT METAL9i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT METAL9i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M9SLOTi { @ M9SLOTi shapes with acute angles between line segments are not allowed.
  INT M9SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9SLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM9 { @ DUM9 shapes with acute angles between line segments are not allowed.
  INT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM9EXCL { @ DM9EXCL shapes with acute angles between line segments are not allowed.
  INT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MDi { @ MDi shapes with acute angles between line segments are not allowed.
  INT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MDSLOTi { @ MDSLOTi shapes with acute angles between line segments are not allowed.
  INT MDSLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MDSLOTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUMD { @ DUMD shapes with acute angles between line segments are not allowed.
  INT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DMDEXCL { @ DMDEXCL shapes with acute angles between line segments are not allowed.
  INT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA12i { @ VIA12i shapes with acute angles between line segments are not allowed.
  INT VIA12i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA12i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA23i { @ VIA23i shapes with acute angles between line segments are not allowed.
  INT VIA23i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA23i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA34i { @ VIA34i shapes with acute angles between line segments are not allowed.
  INT VIA34i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA34i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA45i { @ VIA45i shapes with acute angles between line segments are not allowed.
  INT VIA45i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA45i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA56i { @ VIA56i shapes with acute angles between line segments are not allowed.
  INT VIA56i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA56i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA67i { @ VIA67i shapes with acute angles between line segments are not allowed.
  INT VIA67i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA67i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA78i { @ VIA78i shapes with acute angles between line segments are not allowed.
  INT VIA78i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA78i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA89i { @ VIA89i shapes with acute angles between line segments are not allowed.
  INT VIA89i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA89i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIADi { @ VIADi shapes with acute angles between line segments are not allowed.
  INT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.APi { @ APi shapes with acute angles between line segments are not allowed.
  INT APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PADi { @ PADi shapes with acute angles between line segments are not allowed.
  INT PADi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PADi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CB2i { @ CB2i shapes with acute angles between line segments are not allowed.
  INT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBDi { @ CBDi shapes with acute angles between line segments are not allowed.
  INT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UBMi { @ UBMi shapes with acute angles between line segments are not allowed.
  INT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.WBDMY { @ WBDMY shapes with acute angles between line segments are not allowed.
  INT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPOi { @ RPOi shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NT_Ni { @ NT_Ni shapes with acute angles between line segments are not allowed.
  INT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Ni { @ VTL_Ni shapes with acute angles between line segments are not allowed.
  INT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Pi { @ VTL_Pi shapes with acute angles between line segments are not allowed.
  INT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Ni { @ VTH_Ni shapes with acute angles between line segments are not allowed.
  INT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Pi { @ VTH_Pi shapes with acute angles between line segments are not allowed.
  INT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMi { @ CTMi shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HRIi { @ HRIi shapes with acute angles between line segments are not allowed.
  INT HRIi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HRIi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FWi { @ FWi shapes with acute angles between line segments are not allowed.
  INT FWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PLMIDEi { @ PLMIDEi shapes with acute angles between line segments are not allowed.
  INT PLMIDEi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PLMIDEi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRING { @ SEALRING shapes with acute angles between line segments are not allowed.
  INT SEALRING < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRING < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CSRDMY { @ CSRDMY shapes with acute angles between line segments are not allowed.
  INT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWDMY { @ NWDMY shapes with acute angles between line segments are not allowed.
  INT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HOTWL { @ HOTWL shapes with acute angles between line segments are not allowed.
  INT HOTWL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HOTWL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RHDMY { @ RHDMY shapes with acute angles between line segments are not allowed.
  INT RHDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RHDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPDMY { @ RPDMY shapes with acute angles between line segments are not allowed.
  INT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PMDMY { @ PMDMY shapes with acute angles between line segments are not allowed.
  INT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SDI { @ SDI shapes with acute angles between line segments are not allowed.
  INT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD1DMY { @ ESD1DMY shapes with acute angles between line segments are not allowed.
  INT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD2DMY { @ ESD2DMY shapes with acute angles between line segments are not allowed.
  INT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD3DMY { @ ESD3DMY shapes with acute angles between line segments are not allowed.
  INT ESD3DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD3DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LMARK { @ LMARK shapes with acute angles between line segments are not allowed.
  INT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RHRIDMY { @ RHRIDMY shapes with acute angles between line segments are not allowed.
  INT RHRIDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RHRIDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VARDMY { @ VARDMY shapes with acute angles between line segments are not allowed.
  INT VARDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LOGO { @ LOGO shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.INDDMY { @ INDDMY shapes with acute angles between line segments are not allowed.
  INT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBMi { @ CBMi shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CDUDMY { @ CDUDMY shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.EXCLi { @ EXCLi shapes with acute angles between line segments are not allowed.
  INT EXCLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT EXCLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DMSRMi { @ DMSRMi shapes with acute angles between line segments are not allowed.
  INT DMSRMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMSRMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVTSRM { @ HVTSRM shapes with acute angles between line segments are not allowed.
  INT HVTSRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVTSRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY { @ SRAMDMY shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY { @ CTMDMY shapes with acute angles between line segments are not allowed.
  INT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}

G.3.DNWELLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DNWELLi >0 <90
  NOT ANGLE Y == 45
}
G.3.NWELLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NWELLi >0 <90
  NOT ANGLE Y == 45
}
G.3.DIFFi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DIFFi >0 <90
  NOT ANGLE Y == 45
}
G.3.PDIFFi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PDIFFi >0 <90
  NOT ANGLE Y == 45
}
G.3.NDIFFi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NDIFFi >0 <90
  NOT ANGLE Y == 45
}
G.3.DOD { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DOD >0 <90
  NOT ANGLE Y == 45
}
G.3.ODBLK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ODBLK >0 <90
  NOT ANGLE Y == 45
}
G.3.OD2i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE OD2i >0 <90
  NOT ANGLE Y == 45
}
G.3.POLYGi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE POLYGi >0 <90
  NOT ANGLE Y == 45
}
G.3.DPO { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DPO >0 <90
  NOT ANGLE Y == 45
}
G.3.POBLK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE POBLK >0 <90
  NOT ANGLE Y == 45
}
G.3.PIMPi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PIMPi >0 <90
  NOT ANGLE Y == 45
}
G.3.NIMPi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NIMPi >0 <90
  NOT ANGLE Y == 45
}
G.3.CONTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CONTi >0 <90
  NOT ANGLE Y == 45
}
G.3.M1SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M1SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM1 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM1 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM1EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM1EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M2SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M2SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM2 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM2 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM2EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM2EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M3SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M3SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM3 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM3 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM3EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM3EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M4SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M4SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM4 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM4 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM4EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM4EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M5SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M5SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM5 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM5 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM5EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM5EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M6SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M6SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM6 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM6 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM6EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM6EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M7SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M7SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM7 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM7 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM7EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM7EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M8SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M8SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM8 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM8 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM8EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM8EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.M9SLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M9SLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUM9 { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUM9 >0 <90
  NOT ANGLE Y == 45
}
G.3.DM9EXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DM9EXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.MDi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE MDi >0 <90
  NOT ANGLE Y == 45
}
G.3.MDSLOTi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE MDSLOTi >0 <90
  NOT ANGLE Y == 45
}
G.3.DUMD { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DUMD >0 <90
  NOT ANGLE Y == 45
}
G.3.DMDEXCL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DMDEXCL >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA12i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA12i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA23i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA23i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA34i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA34i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA45i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA45i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA56i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA56i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA67i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA67i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA78i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA78i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIA89i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIA89i >0 <90
  NOT ANGLE Y == 45
}
G.3.VIADi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VIADi >0 <90
  NOT ANGLE Y == 45
}
G.3.APi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE APi >0 <90
  NOT ANGLE Y == 45
}
G.3.PADi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PADi >0 <90
  NOT ANGLE Y == 45
}
G.3.CB2i { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CB2i >0 <90
  NOT ANGLE Y == 45
}
G.3.CBDi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CBDi >0 <90
  NOT ANGLE Y == 45
}
G.3.UBMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE UBMi >0 <90
  NOT ANGLE Y == 45
}
G.3.WBDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE WBDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.RPOi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RPOi >0 <90
  NOT ANGLE Y == 45
}
G.3.NT_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NT_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTL_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTL_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTL_Pi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTL_Pi >0 <90
  NOT ANGLE Y == 45
}
G.3.VTH_Ni { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTH_Ni >0 <90
  NOT ANGLE Y == 45
}
G.3.VTH_Pi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VTH_Pi >0 <90
  NOT ANGLE Y == 45
}
G.3.CTMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CTMi >0 <90
  NOT ANGLE Y == 45
}
G.3.HRIi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HRIi >0 <90
  NOT ANGLE Y == 45
}
G.3.FWi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE FWi >0 <90
  NOT ANGLE Y == 45
}
G.3.PLMIDEi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PLMIDEi >0 <90
  NOT ANGLE Y == 45
}
G.3.SEALRING { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SEALRING >0 <90
  NOT ANGLE Y == 45
}
G.3.CSRDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CSRDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.NWDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE NWDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.HOTWL { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HOTWL >0 <90
  NOT ANGLE Y == 45
}
G.3.RHDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RHDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.RPDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RPDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.PMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE PMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.SDI { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SDI >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD1DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD1DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD2DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD2DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.ESD3DMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE ESD3DMY >0 <90
  NOT ANGLE Y == 45
}
G.3.LMARK { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE LMARK >0 <90
  NOT ANGLE Y == 45
}
G.3.RHRIDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE RHRIDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.VARDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE VARDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.LOGO { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE LOGO >0 <90
  NOT ANGLE Y == 45
}
G.3.INDDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE INDDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.CBMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CBMi >0 <90
  NOT ANGLE Y == 45
}
G.3.CDUDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CDUDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.EXCLi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE EXCLi >0 <90
  NOT ANGLE Y == 45
}
G.3.DMSRMi { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE DMSRMi >0 <90
  NOT ANGLE Y == 45
}
G.3.HVTSRM { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE HVTSRM >0 <90
  NOT ANGLE Y == 45
}
G.3.SRAMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE SRAMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.CTMDMY { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE CTMDMY >0 <90
  NOT ANGLE Y == 45
}
G.3.M1x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M1x >0 <90
  NOT ANGLE Y == 45
}
G.3.M2x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M2x >0 <90
  NOT ANGLE Y == 45
}
G.3.M3x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M3x >0 <90
  NOT ANGLE Y == 45
}
G.3.M4x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M4x >0 <90
  NOT ANGLE Y == 45
}
G.3.M5x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M5x >0 <90
  NOT ANGLE Y == 45
}
G.3.M6x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M6x >0 <90
  NOT ANGLE Y == 45
}
G.3.M7x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M7x >0 <90
  NOT ANGLE Y == 45
}
G.3.M8x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M8x >0 <90
  NOT ANGLE Y == 45
}
G.3.M9x { @ Only shapes that are orthogonal or on a 45-degree angle are allowed.
  Y = ANGLE M9x >0 <90
  NOT ANGLE Y == 45
}




//NT_N CHECKS
//============
NTN_OD        = OD     AND NTN
NTN_PO        = POLY   AND NTN
NTN_GATE_W    = NTN_PO INSIDE EDGE NTN_OD
NTN_HV_GATE_W = NTN_GATE_W INSIDE EDGE OD2

NT_N.W.1 { @ Width >= 0.62 
  INT NTN < 0.62 ABUT < 90 SINGULAR REGION
}
NT_N.W.2 { @ Channel length of a 1.0V or 1.2V native device >= 0.30 
  INT NTN_GATE_W < 0.30 ABUT < 90 REGION
}
NT_N.W.3 { @ Channel length of a 2.5V or 3.3V native device >= 1.20 
  INT NTN_HV_GATE_W < 1.20 ABUT < 90 REGION
}
NT_N.S.1 { @ Space >= 0.62 
  EXT NTN < 0.62 ABUT < 90 SINGULAR REGION
}

NT_N.S.2 { @ Space to {Active outside NT_N} >= 0.38 
  EXT DACT NTN < 0.38 ABUT < 90 OVERLAP SINGULAR
}
NT_N.S.3 { @ Space to NW [overlap is not allowed] >= 1.20 
  EXT NTN NWELLi < 1.20 ABUT < 90 INSIDE ALSO SINGULAR
}

NT_N.EN.1 { @ Enclosure of N+OD (minimum = maximum) = 0.26 
  A = NTN INTERACT OD
  B = OD INTERACT NTN
  C = SIZE B BY 0.26
  D = SIZE A BY -0.26
  A XOR C
  B XOR D
}
NT_N.EX.1 { @ PO extension on {OD inside NT_N} (PO endcap) >= 0.35 
  ENC NTN_OD POLY < 0.35 ABUT < 90 SINGULAR
}
NT_N.R.1 { @ Overlap of DNW is not allowed.   
  NTN AND DNW
}
NT_N.R.2 { @ Only one OD is allowed in an NT_N (except for NMOS capacitors with same potential).   
  NTN ENCLOSE OD > 1
}
NT_N.R.3 { @ P+OD is not allowed in an NT_N.   
  PPOD AND NTN
}



//VTL_N CHECKS
//============

VTL_N.W.1 { @ Width >= 0.31 
  INT VTLN < 0.31 ABUT < 90 SINGULAR REGION
}
VTL_N.W.2 { @ Channel length of 1.2V low Vt NMOS >= 0.13 
  A = LV_NGATE_W INSIDE EDGE VTLN
  INT A < 0.13 ABUT < 90 REGION
}
VTL_N.S.1 { @ Space >= 0.31 
  EXT VTLN < 0.31 ABUT < 90 SINGULAR REGION
}
VTL_N.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  VTLN AND C
}

// VTL_N.S.3 is checked by VTL_N.S.2

VTL_N.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  C NOT VTLN
}

// VTL_N.EX.2 is checked by VTL_N.EX.1

VTL_N.R.1 { @ Overlap of {NW OR NT_N} is not allowed.   
  VTLN AND NWEL
  VTLN AND NTN
}

//VTL_P CHECKS
//============

VTL_P.W.1 { @ Width >= 0.31 
  INT VTLP < 0.31 ABUT < 90 SINGULAR REGION
}
VTL_P.W.2 { @ Channel length of 1.2V low Vt PMOS >= 0.13 
  A = LV_PGATE_W INSIDE EDGE VTLP
  INT A < 0.13 ABUT < 90 REGION
}
VTL_P.S.1 { @ Space >= 0.31 
  EXT VTLP < 0.31 ABUT < 90 SINGULAR REGION
}
VTL_P.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  VTLP AND C
}

// VTL_P.S.3 is checked by VTL_P.S.2

VTL_P.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  C NOT VTLP
}

// VTL_P.EX.2 is checked by VTL_P.EX.1

VTL_P.R.1 { @ Overlap of {PW OR NT_N} is not allowed.   
  VTLP NOT NWEL
  VTLP AND NTN
}



//VTH_N CHECKS
//============

VTH_N.TITLE { @ Only core (1.0V, 1.2V) has high Vt devices.
  VTHN AND OD2
}  
VTH_N.W.1 { @ Width >= 0.31 
  INT VTHN < 0.31 ABUT < 90 SINGULAR REGION
}
VTH_N.W.2 { @ Channel length of 1.0V or 1.2V high Vt NMOS >= 0.13 
  A = LV_NGATE_W INSIDE EDGE VTHN
  INT A < 0.13 ABUT < 90 REGION
}
VTH_N.S.1 { @ Space >= 0.31 
  EXT VTHN < 0.31 ABUT < 90 SINGULAR REGION
}
VTH_N.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  VTHN AND C
}

// VTH_N.S.3 is checked by VTH_N.S.2

VTH_N.EX.1 { @ Extension on GATE in poly endcap direction. >= 0.18 
  A = GATE INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  C NOT VTHN
}

// VTH_N.EX.2 is checked by VTH_N.EX.1

VTH_N.R.1 { @ Overlap of {NW OR NT_N} is not allowed.   
  VTHN AND NWEL
  VTHN AND NTN
}

//VTH_P CHECKS
//============

VTH_P.TITLE { @ Only core (1.0V, 1.2V) has high Vt devices.
  VTHP AND OD2
}  
VTH_P.W.1 { @ Width >= 0.31 
  INT VTHP < 0.31 ABUT < 90 SINGULAR REGION
}
VTH_P.W.2 { @ Channel length of a 1.0V or 1.2V high Vt PMOS >= 0.13 
  A = LV_PGATE_W INSIDE EDGE VTHP
  INT A < 0.13 ABUT < 90 REGION
}
VTH_P.S.1 { @ Space >= 0.31 
  EXT VTHP < 0.31 ABUT < 90 SINGULAR REGION
}
VTH_P.S.2 { @ Space to GATE in poly endcap direction >= 0.18 
  A = GATE NOT INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  VTHP AND C
}

// VTH_P.S.3 is checked by VTH_P.S.2

VTH_P.EX.1 { @ Extension on GATE in poly endcap direction >= 0.18 
  A = GATE INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (0.27 - 0.18)) OR A
  C = SIZE B BY 0.18
  C NOT VTHP
}

// VTH_P.EX.2 is checked by VTH_P.EX.1

VTH_P.R.1 {
  VTHP NOT NWEL
  VTHP AND NTN
}


//OD CHECKS
//=========

#IFDEF CHECK_DENSITY_IN_ODBLK
OD_EXC = (((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY
#ELSE
OD_EXC = ((((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY) OR ODBLK
#ENDIF

#IFDEF FULL_CHIP
ODx = (ALL_OD NOT OD_EXC) NOT EMPTY_AREA
CHIP_NOT_OD_EXC = CHIP_CHAMFERED NOT OD_EXC 
#ELSE
ODx = ALL_OD NOT OD_EXC
CHIP_NOT_OD_EXC = CHIP NOT OD_EXC
#ENDIF

OD.W.1 { @ Width [Active] >= 0.150 
  INT OD < 0.15 ABUT < 90 SINGULAR REGION
}

// OD.W.2 is checked by OD.W.1

OD.S.1 { @ Space >= 0.210 
  EXT OD < 0.21 ABUT < 90 SINGULAR REGION
}

// OD.S.2 is checked by PP.R.2

OD.S.3 { @ N+ACTIVE space to NW >= 0.310 
  A = NPOD NOT ODWR
  (EXT A NWELLi < 0.31 ABUT < 90 OVERLAP SINGULAR REGION) NOT INSIDE EXCL_SRM
}
OD.S.4 { @ PW STRAP space to NW >= 0.240 
  (EXT PPOD NWELLi < 0.24 ABUT < 90 OVERLAP SINGULAR REGION) NOT INSIDE EXCL_SRM
}
OD.S.5 { @ GATE space to Butted_STRAP [point projection]. Please also refer to NP.S.6/ PP.S.6 for related rules. >= 0.320 
  X = EXPAND EDGE GATEN_W OUTSIDE BY 0.32
  X TOUCH PSTP
  Y = EXPAND EDGE GATEP_W OUTSIDE BY 0.32
  Y TOUCH NSTP
}
OD.S.6 { @ N+OD [outside {NW interact with DNW}] space to DNW >= 2.930 
  NWRG = NWEL INTERACT DNW
  X = NPOD OUTSIDE NWRG
  (EXT DNW X < 2.93 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
OD.EN.1 { @ NW STRAP enclosure by NW >= 0.240 
  (ENC NPOD NONWR < 0.24 ABUT < 90 OVERLAP SINGULAR REGION) NOT INSIDE EXCL_SRM
}
OD.EN.2 { @ P+ACTIVE enclosure by NW >= 0.310 
  (ENC PPOD NONWR < 0.31 ABUT < 90 OVERLAP SINGULAR REGION) NOT INSIDE EXCL_SRM
}
OD.A.1 { @ Area >= 0.122 
  AREA OD < 0.122
}
OD.A.2 { @ Enclosed area >= 0.150 
  HOLES OD < 0.15 INNER
}  

CHIPU_od25   = SIZE CHIP BY 25
CHIPU_od50   = SIZE CHIP BY 50
CHIPU_od75   = SIZE CHIP BY 75
CHIPU_od100   = SIZE CHIP BY 100
CHIPU_od125   = SIZE CHIP BY 125
CHIPU_od150   = SIZE CHIP BY 150
CHIPU_od175   = SIZE CHIP BY 175
CHIPU_od200   = SIZE CHIP BY 200
CHIPU_od225   = SIZE CHIP BY 225

OD.DN.1 { @ {OD OR DOD} local density (minimum) over window 500um x 500um stepping 250um >= 20%
  D0 = DENSITY ODx CHIP_NOT_OD_EXC < 0.2 WINDOW 500 STEP 250 BACKUP PRINT OD_DN_1.density 
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == 500
  D0 NOT D
  D1 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D7 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC < 0.20 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)  
}
OD.DN.2 { @ {OD OR DOD} local density (maximum) over window 500um x 500um stepping 250um <= 80% 
  D0 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP PRINT OD_DN_2.density 
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D = RECTANGLE D0 == 500
  D0 NOT D
  D1 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od25
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D2 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od50
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D3 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od75
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D4 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od100
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D5 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od125
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D6 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od150
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D7 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od175
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D8 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od200
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D9 = DENSITY ODx CHIP_NOT_OD_EXC > 0.8 WINDOW 500 STEP 250 BACKUP INSIDE OF LAYER CHIPU_od225
          [ AREA(ODx)/AREA(CHIP_NOT_OD_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
OD.DN.3 { @ {OD OR DOD} density across full chip (minimum) >= 25%
  DENSITY ALL_OD < 0.25 PRINT OD_DN_3.density
}
OD.DN.4 { @ {OD OR DOD} density across full chip (maximum) <= 75%
  DENSITY ALL_OD > 0.75 PRINT OD_DN_4.density
}  
OD.R.1 { @ Width (J) of at least one segment of boundary between ACTIVE and Butted STRAP >= 0.30
	@ When J<0.3um, length (T) of {ACTIVE (source) interact with Butted_STRAP}. <= 0.60
  SD = (DACT INTERACT GATE) NOT GATE
  BUTT_EDGE = SD COIN OUTSIDE EDGE DSTP
  BUTT_LONG_EDGE = LENGTH BUTT_EDGE >= 0.30
  BUTT_EXP = (EXPAND EDGE BUTT_EDGE INSIDE BY 0.005 EXTEND BY 0.005) AND SD
  BUTT_EXP_SHORT = BUTT_EXP NOT WITH EDGE BUTT_LONG_EDGE
  CHECK_SD = SD INTERACT BUTT_EXP_SHORT
  CHECK_EDGE = (CHECK_SD OUTSIDE EDGE GATE) OUTSIDE EDGE DSTP
  CHECK_EDGE_LONG = PATH LENGTH CHECK_EDGE > 0.6
  NARROW_SD1 = INT CHECK_EDGE_LONG < 0.3 ABUT < 90 OPPOSITE REGION
  NARROW_SD2 = NARROW_SD1 INTERACT BUTT_EXP_SHORT
  NARROW_SD3 = ((SIZE (NARROW_SD1 OUTSIDE NARROW_SD2) BY 0.001) AND SD) INTERACT NARROW_SD2
  NARROW_SD = NARROW_SD2 OR NARROW_SD3
  NARROW_SD_EDGE = NARROW_SD COIN INSIDE EDGE OD
  PATH LENGTH NARROW_SD_EDGE > 0.6
}



//OD2 CHECKS
//==========

OD2.W.1 { @ Width >= 0.620 
  INT OD2 < 0.62 ABUT < 90 SINGULAR REGION
}

OD2.S.1 { @ Space >= 0.86 
  EXT OD2 < 0.86 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ Space to ACTIVE >= 0.27 
  EXT OD2 DACT < 0.27 ABUT < 90 SINGULAR REGION
}
OD2.S.3 { @ Space to 1.0V or 1.2V GATE >= 0.34 
   A = OD2 INSIDE EDGE DACT
   EXT A GATE_W < 0.34 ABUT < 90 REGION
}
OD2.S.4 { @ Space to NW. Space = 0 is allowed. >= 0.62 
  EXT OD2 NWEL < 0.62 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EN.1 { @ Enclosure of 2.5V or 3.3V GATE >= 0.34 
  OD2_BEDGE = OD2 INSIDE EDGE OD
  ENC GATE_W OD2_BEDGE < 0.34 ABUT < 90 REGION
  GATE CUT OD2
}
OD2.EX.1 { @ Extension on ACTIVE >= 0.27 
   CHECK_EDGE_N = ENC [NACT] OD2 < 0.27 ABUT < 90 SINGULAR
   CHECK_EDGE_N NOT COIN OUTSIDE EDGE PSTP
   CHECK_EDGE_P = ENC [PACT] OD2 < 0.27 ABUT < 90 SINGULAR
   CHECK_EDGE_P NOT COIN OUTSIDE EDGE NSTP
   OD2 INSIDE DACT
   Y = DACT INTERACT OD2
   Z = Y NOT OD2
   Z OUTSIDE GATE
}
OD2.EX.2 { @ NW extension on OD2. Extension = 0 is allowed. >= 0.62 
  ENC OD2 NWEL < 0.62 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on NW. Extension = 0 is allowed. >= 0.62 
  ENC NWEL OD2 < 0.62 ABUT < 90 > 0 SINGULAR REGION
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 is allowed. >= 0.62 
  X = OD2 AND NWEL
  INT X < 0.62 ABUT < 90 SINGULAR REGION
}


//PO CHECKS
//=========

POLY_EDGE_45 = POLY ANGLE == 45
POLY_EDGE_45L = LENGTH POLY_EDGE_45 >= 0.39

// PO.W.1_1.0V_1.2V is checked by PO.W.3
// PO.W.2_1.0V_1.2V is checked by PO.W.3

#IFDEF 1.8V
PO.W.1_1.8V { @ Channel length of 1.8V PMOS	>=	0.18 
  INT HV_PGATE_W < 0.18 ABUT < 90 REGION
}
PO.W.2_1.8V { @ Channel length of 1.8V NMOS	>=	0.18 
  INT HV_NGATE_W < 0.18 ABUT < 90 REGION
}
#ENDIF

#IFDEF 2.5V
PO.W.1_2.5V { @ Channel length of 2.5V PMOS	>=	0.28 
  INT HV_PGATE_W < 0.28 ABUT < 90 REGION
}
PO.W.2_2.5V { @ Channel length of 2.5V NMOS	>=	0.28 
  INT HV_NGATE_W < 0.28 ABUT < 90 REGION
}
#ENDIF

#IFDEF 3.3V
PO.W.1_3.3V { @ Channel length of 3.3V PMOS	>=	0.30 
  INT HV_PGATE_W < 0.30 ABUT < 90 REGION
}
PO.W.2_3.3V { @ Channel length of 3.3V NMOS	>=	0.35 
  INT HV_NGATE_W < 0.35 ABUT < 90 REGION
}
#ENDIF

PO.W.3 { @ Width [interconnect] >= 0.13 
  INT POLY < 0.13 ABUT < 90 SINGULAR REGION
}
PO.W.4 { @ Width of 45-degree FIELD PO [for length >= 0.39] >= 0.16 
  INT POLY_EDGE_45L < 0.16 ABUT < 90 REGION
}
PO.S.1 { @ Space >= 0.18 
  EXT POLY < 0.18 ABUT < 90 SINGULAR REGION
}
PO.S.2 { @ GATE space in the same OD >= 0.18 
  EXT LV_GATE < 0.18 ABUT < 90 SINGULAR REGION
}
PO.S.3 { @ {GATE inside OD2} space in the same OD >= 0.25 
  EXT HV_NGATE_W < 0.25 REGION
  EXT HV_PGATE_W < 0.25 REGION
}
PO.S.4 { @ FIELD PO space to OD >= 0.07 
  EXT POLY OD < 0.07 ABUT < 89.5 SINGULAR REGION
}
PO.EX.1 { @ Extension on OD (endcap)  Poly endcap must contain a rectangular area where width = the width of the poly gate, and length >= 0.18 um.  PO.S.4, FIELD PO space to OD, will be automatic. >= 0.18 
  ENC OD POLY < 0.18 ABUT < 89.5 SINGULAR REGION
}
PO.EX.2 { @ OD extension on PO >= 0.23 
  ENC POLY OD < 0.23 ABUT < 89.5 OPPOSITE SINGULAR REGION
}
PO.A.1 { @ Area >= 0.09 
  AREA POLY < 0.09
}
PO.A.2 { @ Enclosed area >= 0.15 
  HOLES POLY < 0.15 INNER
}  

PO_DENSITY = DENSITY ALL_POLY < 0.14 PRINT PO_DN_1.density

PO.DN.1 { @ {PO OR DPO} density across full chip 14%  
  COPY PO_DENSITY
}
PO.R.1 { @ The gate must be a rectangle orthogonal to the grid. (A bent gate is not allowed).   
  NORM_GATE_W = GATE_W OUTSIDE EDGE VARDMY
  EXT GATE_W < 0.13 ABUT == 135 INTERSECTING ONLY
  INT GATE_W < 0.13 ABUT == 135 INTERSECTING ONLY
  EXT NORM_GATE_W < 0.13 ABUT == 90 INTERSECTING ONLY
  INT NORM_GATE_W < 0.13 ABUT == 90 INTERSECTING ONLY
}

// PO.R.2 is not able to check




//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD   // NP edge to form/abut butted tap

NP.W.1 { @ Width >= 0.31 
  (INT NP < 0.31 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.S.1 { @ Space >= 0.31 
  (EXT NP < 0.31 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.S.2 { @ Space to P+ACTIVE (non-butted) >= 0.18 
  (EXT NP PACT < 0.18 ABUT < 90 > 0 INSIDE ALSO SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
}
NP.S.3 { @ Space to PW STRAP (non-butted) >= 0.03 
  (EXT NP PSTP < 0.03 ABUT < 90 > 0 INSIDE ALSO SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
}
NP.S.4 { @ {NP edge on OD} space to PMOS GATE >= 0.40 
  (EXT GATEP_W NP_BEDGE < 0.40 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}

// NP.S.5 is checked by PP.R.2
// NP.S.6 is checked by PP.R.1/PP.R.2
ODPO_RES_unsi = ODPO_RES INTERACT RPO
NP.S.7 { @ Space to P type unsilicided PO/OD >= 0.20 
  PYRE = ODPO_RES_unsi AND PP 		// P-type PO and OD resistor
  (EXT PYRE NP < 0.20 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}

// NP.EN.1 is checked by PP.EN.1

NP.EN.2 { @ Enclosure of NW STRAP >= 0.03 
  (ENC NSTP NP < 0.03 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
NP.EX.1 { @ Extension on N+ACTIVE >= 0.18 
  A = NACT NOT ODWR
  (ENC A NP < 0.18 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [A] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}

// NP.EX.2 is checked by NP.EN.2/PP.R.2

NP.EX.3 { @ Extension on N type unsilicided PO/OD >= 0.20 
  (ENC ODPO_RES_unsi NP < 0.20 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= 0.40 
  (ENC GATEN_W NP_BEDGE < 0.40 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}
NP.O.1 { @ Overlap of OD >= 0.18 
  (INT OD NP < 0.18 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NP.A.1 { @ Area >= 0.25 
  AREA NP < 0.25
}
NP.A.2 { @ Enclosed area >= 0.25 
  (HOLES NP < 0.25 INNER) NOT INSIDE EXCL_SRM
}  
NP.R.1 { @ NP must fully cover {((NMOS GATE SIZING 0.03) AND PO) SIZING 0.27}.   
  EXGATE_NP = SIZE ((SIZE GATE_NP BY 0.03) AND POLY) BY 0.27
  (EXGATE_NP NOT NP) NOT INSIDE EXCL_SRM
}

// NP.R.2 is checked by PP.R.2


//PP CHECKS
//=========

// Expand edges outward from OD and extended side to side to form a rectangle.

PP_BEDGE = PP INSIDE EDGE OD   // PP edge to form/abut butted tap
SR_EXC   = EXT SR_EDGE < 75 ABUT == 90 REGION INTERSECTING ONLY
PP_CORE  = ((PP NOT CSRDMY) NOT SR_EXC) NOT SR_EDGE

PP.W.1 { @ Width >= 0.31 
  (INT PP < 0.31 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.S.1 { @ Space >= 0.31 
  (EXT PP < 0.31 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.S.2 { @ Space to N+ACTIVE (non-butted) >= 0.18 
  (EXT PP NACT < 0.18 ABUT < 90 > 0 INSIDE ALSO SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
PP.S.3 { @ Space to NW STRAP (non-butted) >= 0.03 
  (EXT PP NSTP < 0.03 ABUT < 90 > 0 INSIDE ALSO SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT PPOD) NOT INSIDE EXCL_SRM
}
PP.S.4 { @ {PP edge on OD} space to NMOS GATE >= 0.40 
  (EXT GATEN_W PP_BEDGE < 0.40 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}

// PP.S.5 is checked by PP.R.2
// PP.S.6 is checked by NP.R.1/PP.R.2

PP.S.7 { @ Space to N type unsilicided PO/OD >= 0.20 
  NYRE = ODPO_RES_unsi AND NP 		// N-type PO and OD resistor
  (EXT NYRE PP < 0.20 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO and LOGO) >= 0.20 
  ILP_NOT_LOGO = ( POLY NOT LOGO) NOT CDUDMY
  (ENC ILP_NOT_LOGO IMP < 0.20 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
  (ILP_NOT_LOGO NOT IMP) NOT INSIDE EXCL_SRM 
}
PP.EN.2 { @ Enclosure of PW STRAP >= 0.03 
  (ENC PSTP PP_CORE < 0.03 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [PSTP] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
  (((OD NOT ODWR) NOT LOGO) NOT CDUDMY) NOT IMP
}
PP.EX.1 { @ Extension on P+ACTIVE >= 0.18 
  IMP1 = NP OR PP_CORE
  (ENC PACT PP_CORE < 0.18 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
  X = ENC [PACT] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE EXCL_SRM
  OD COIN INSIDE EDGE IMP1 
  // IMP cannot coincident OD except butting diffusion edge. PP.EX.1,PP.EN.2/NP.EX.1,NP.EN.2
}

// PP.EX.2 is checked by PP.EN.2/PP.R.2

PP.EX.3 { @ Extension on P type unsilicided PO/OD >= 0.20 
  (ENC ODPO_RES_unsi PP < 0.20 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= 0.40 
  (ENC GATEP_W PP_BEDGE < 0.40 ABUT < 90 OPPOSITE REGION) NOT INSIDE EXCL_SRM
}
PP.O.1 { @ Overlap of OD >= 0.18 
  (INT OD PP_CORE < 0.18  ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
PP.A.1 { @ Area >= 0.25 
  AREA PP < 0.25
}
PP.A.2 { @ Enclosed area >= 0.25 
  (HOLES PP < 0.25 INNER) NOT INSIDE EXCL_SRM
}  
PP.R.1 { @ PP must fully cover {((PMOS GATE SIZING 0.03) AND PO) SIZING 0.27}.   
  EXGATE_PP = SIZE ((SIZE GATE_PP BY 0.03) AND POLY) BY 0.27
  (EXGATE_PP NOT PP) NOT INSIDE EXCL_SRM
}
PP.R.2 { @ Overlap of NP is not allowed.   
  (PP AND NP) NOT INSIDE EXCL_SRM
}


//LDN CHECKS
//==========

OD2D = SIZE OD2 BY -0.03
OD2U = SIZE OD2 BY 0.03

NP_NOT_NW = NP NOT NWEL
NLDDN1 = ((NP_NOT_NW NOT OD2D) NOT RHDMY) NOT VARDMY
NLDDN1V = SIZE (SIZE (SIZE NLDDN1 BY 0.14) BY -0.28) BY 0.14
NLDDN2 = ((NP_NOT_NW AND OD2U) NOT RHDMY) NOT VARDMY
NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY 0.14) BY -0.28) BY 0.14

PP_AND_NW = PP AND NWEL
PLDDP1 = ((PP_AND_NW NOT OD2D) NOT RHDMY) NOT VARDMY
PLDDP1V = SIZE (SIZE (SIZE PLDDP1 BY 0.14) BY -0.28) BY 0.14
PLDDP2 = ((PP_AND_NW AND OD2U) NOT RHDMY) NOT VARDMY
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY 0.14) BY -0.28) BY 0.14

VTC_N = SIZE (SIZE (SIZE (DMSRMi NOT NWELLi) BY 0.29) BY -0.58) BY 0.29
VTL_N_LD = SIZE (SIZE (SIZE ((OD2 OR NWEL) OR VTLN) BY 0.14) BY -0.28) BY 0.14
VTL_P_LD = SIZE (SIZE (SIZE ((NWEL NOT OD2) NOT VTLP) BY 0.14) BY -0.28) BY 0.14
CHIP_HVTSRM = CHIP INTERACT HVTSRM
VTHNx = VTHN INTERACT CHIP_HVTSRM
VTHPx = VTHP INTERACT CHIP_HVTSRM
VTH_N_LD = SIZE (SIZE (SIZE ((HVTSRM NOT NWEL) OR VTHNx) BY 0.14) BY -0.28) BY 0.14
VTH_P_LD = SIZE (SIZE (SIZE ((HVTSRM AND NWEL) OR VTHPx) BY 0.14) BY -0.28) BY 0.14

LDN.EX.1 { @ NP extension on OD2D >= 0.31 
  A = INT NLDDN1V < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT NLDDN1V < 0.31 ABUT < 90 CORNER SINGULAR 
  INT NLDDN1V < 0.31 ABUT < 90 PROJ == 0
  EXT NLDDN1V < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT NLDDN1V < 0.31 ABUT < 90 PROJ == 0
}
LDN.O.1 { @ NP overlap of OD2U >= 0.31 
  A = INT NLDDN2V < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT NLDDN2V < 0.31 ABUT < 90 CORNER SINGULAR 
  INT NLDDN2V < 0.31 ABUT < 90 PROJ == 0
  EXT NLDDN2V < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT NLDDN2V < 0.31 ABUT < 90 PROJ == 0
}

// LDN.EX.2 is checked by LDN.EX.1


//LDN GUIDELINES
//==============

// LDN.EX.3 is checked by LDN.EX.1
// LDN.EX.4 is checked by LDN.EX.1


//LDP CHECKS
//==========

LDP.EX.1 { @ PP extension on OD2D >= 0.31 
  A = INT PLDDP1V < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT PLDDP1V < 0.31 ABUT < 90 CORNER SINGULAR 
  INT PLDDP1V < 0.31 ABUT < 90 PROJ == 0
  EXT PLDDP1V < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT PLDDP1V < 0.31 ABUT < 90 PROJ == 0
}
LDP.O.1 { @ PP overlap of OD2U >= 0.31 
  A = INT PLDDP2V < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT PLDDP2V < 0.31 ABUT < 90 CORNER SINGULAR 
  INT PLDDP2V < 0.31 ABUT < 90 PROJ == 0
  EXT PLDDP2V < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT PLDDP2V < 0.31 ABUT < 90 PROJ == 0
}

// LDP.O.2 is checked by LDP.EX.1


//LDP GUIDELINES
//==============

// LDP.EX.3 is checked by LDP.EX.1
// LDP.EX.4 is checked by LDP.EX.1


//VT CHECKS
//=========

#IFDEF GUIDELINE

VT.S.1 { @ OD2 space to VTL_N >= 0.31 
  A = INT VTL_N_LD < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_N_LD < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT VTL_N_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  INT VTL_N_LD < 0.31 ABUT < 90 PROJ == 0
  EXT VTL_N_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT VTL_N_LD < 0.31 ABUT < 90 PROJ == 0
}

// VT.S.2 is checked by VT.S.1
// VT.S.3 is checked by VT.EX.2

VT.S.4 { @ HVTSRM space to VTH_P >= 0.31 
  A = INT VTH_P_LD < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT VTH_P_LD < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT VTH_P_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  INT VTH_P_LD < 0.31 ABUT < 90 PROJ == 0
  EXT VTH_P_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT VTH_P_LD < 0.31 ABUT < 90 PROJ == 0
}
VT.EX.1 { @ DMSRM extension on NW >= 0.31 
  A = INT VTC_N < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT VTC_N < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.58 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.58 0.31 ORTHOGONAL ONLY
  INT VTC_N < 0.31 ABUT < 90 CORNER SINGULAR 
  INT VTC_N < 0.31 ABUT < 90 PROJ == 0
  EXT VTC_N < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT VTC_N < 0.31 ABUT < 90 PROJ == 0
}
VT.EX.2 { @ HVTSRM extension on NW >= 0.31 
  A = INT VTH_N_LD < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT VTH_N_LD < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT VTH_N_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  INT VTH_N_LD < 0.31 ABUT < 90 PROJ == 0
  EXT VTH_N_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT VTH_N_LD < 0.31 ABUT < 90 PROJ == 0
}
VT.EX.3 { @ NW extension on VTL_P >= 0.31 
  A = INT VTL_P_LD < 0.31 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_P_LD < 0.31 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.28 0.31 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.28 0.31 ORTHOGONAL ONLY
  INT VTL_P_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  INT VTL_P_LD < 0.31 ABUT < 90 PROJ == 0
  EXT VTL_P_LD < 0.31 ABUT < 90 CORNER SINGULAR 
  EXT VTL_P_LD < 0.31 ABUT < 90 PROJ == 0
}

#ENDIF


//RPO CHECKS
//==========

NOGT  = (GATE NOT ESD1DMY) NOT ESD2DMY  // Normal gates
FPO1A = (FPO1 NOT ESD1DMY) NOT ESD2DMY

RPO.W.1 { @ Width >= 0.43 
  INT RPO < 0.43 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= 0.43 
  EXT RPO < 0.43 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= 0.22 
  EXT RPO OD < 0.22 ABUT < 90 SINGULAR
}
RPO.S.3 { @ Space to CO [overlap is not allowed] >= 0.22 
  EXT RPO CO < 0.22 ABUT < 90 INSIDE ALSO SINGULAR
}
RPO.S.4 { @ Space to GATE [overlap is not allowed except ESD circuit] >= 0.38 
  RPO AND NOGT
  EXT RPO GATE < 0.38 ABUT < 90 SINGULAR
}
RPO.S.5 { @ Space to PO >= 0.30 
  EXT RPO FPO1 < 0.3 ABUT < 90 SINGULAR
}
RPO.EX.1 { @ Extension on unsilicided OD >= 0.22 
  ENC OD RPO < 0.22 ABUT < 90 SINGULAR
}
RPO.EX.2 { @ OD extension on RPO >= 0.22 
  ENC RPO OD < 0.22 ABUT < 90 SINGULAR
}
RPO.EX.3 { @ Extension on unsilicided PO >= 0.22 
  ENC FPO1A RPO < 0.22 ABUT < 90 SINGULAR
}
RPO.A.1 { @ Area >= 1.00 
  AREA RPO < 1.0
}
RPO.R.1.PO { @ Butted NP/PP on unsilicided PO is not allowed.
    NX = RPO_PO AND NP
    PX = RPO_PO AND PP    
    Y  = NX INTERACT PX
    RPO_PO INTERACT Y
}  
RPO.R.1.OD { @ Butted NP/PP on unsilicided OD is not allowed.
    NX = RPO_OD AND NP
    PX = RPO_OD AND PP    
    Y  = NX INTERACT PX
    RPO_OD INTERACT Y
}  

RPO.A.2 { @ Enclosed Area >= 1.00  
  A = HOLES RPO INNER
  B = A NOT RPO
  AREA B < 1.0
}



// M1 SIZE
//=========
M1Wide0.3 = (SIZE M1 BY 0.149 UNDEROVER TRUNCATE 0.149) AND M1
M1Wide1.4 = (SIZE M1Wide0.3 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M1Wide0.3
M1Wide7   = (SIZE M1Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M1Wide1.4

M2Wide0.4 = (SIZE M2 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M2
M2Wide1.4 = (SIZE M2Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M2Wide0.4
M2Wide7   = (SIZE M2Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M2Wide1.4

// M2 SIZE
//=========
M3Wide0.4 = (SIZE M3 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M3
M3Wide1.4 = (SIZE M3Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M3Wide0.4
M3Wide7   = (SIZE M3Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M3Wide1.4
// M3 SIZE
//=========
M4Wide0.4 = (SIZE M4 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M4
M4Wide1.4 = (SIZE M4Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M4Wide0.4
M4Wide7   = (SIZE M4Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M4Wide1.4
// M4 SIZE
//=========
M5Wide0.4 = (SIZE M5 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M5
M5Wide1.4 = (SIZE M5Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M5Wide0.4
M5Wide7   = (SIZE M5Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M5Wide1.4
// M5 SIZE
//=========
M6Wide0.4 = (SIZE M6 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M6
M6Wide1.4 = (SIZE M6Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M6Wide0.4
M6Wide7   = (SIZE M6Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M6Wide1.4
// M6 SIZE
//=========
M7Wide0.4 = (SIZE M7 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M7
M7Wide1.4 = (SIZE M7Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M7Wide0.4
M7Wide7   = (SIZE M7Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M7Wide1.4
// M7 SIZE
//=========
M8Wide0.4 = (SIZE M8 BY 0.194 UNDEROVER TRUNCATE 0.194) AND M8
M8Wide1.4 = (SIZE M8Wide0.4 BY 0.7 UNDEROVER TRUNCATE 0.7) AND M8Wide0.4
M8Wide7   = (SIZE M8Wide1.4 BY 3.5 UNDEROVER TRUNCATE 3.5) AND M8Wide1.4
UBM_EXDD    = SIZE UBM BY 5 INSIDE OF MDx STEP 0.32 	// For RDL


//METAL1 SLOT CHECKS
//==================

M1EXD       = M1x NOT SLT_EXD
M1InnerHole = HOLES M1EXD INNER
M1BigHole   = SIZE M1InnerHole BY -5 	// Holes with width less than 10um will be filled back
M1Hole      = M1InnerHole OUTSIDE M1BigHole	
M1HoleSpace = M1Hole NOT M1EXD
FIM1c       = M1EXD OR M1HoleSpace
FIM1Y       = (SIZE (SIZE FIM1c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM1c  
LM1X        = ENCLOSE RECTANGLE FIM1Y MS_R_1_W MS_R_1_L
M1HoleD     = M1HoleSpace AND LM1X

MS.R.1.M1 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M1WideEXD = M1Wide7 NOT SLT_EXD
  X = (SIZE M1WideEXD BY MS_R_1_W_s UNDEROVER) AND M1WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M1HoleD LM1X

MS.DN.1.M1 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM1X M1HoleD < MS_DN_1
    [ AREA(M1HoleD) / AREA(LM1X) ] RDB M1Hole.density LM1X M1HoleD 
}

DISCONNECT

// MS.R.2.M1 is not able to check




//METAL2 SLOT CHECKS
//==================

M2EXD       = M2x NOT SLT_EXD
M2InnerHole = HOLES M2EXD INNER
M2BigHole   = SIZE M2InnerHole BY -5 	// Holes with width less than 10um will be filled back
M2Hole      = M2InnerHole OUTSIDE M2BigHole	
M2HoleSpace = M2Hole NOT M2EXD
FIM2c       = M2EXD OR M2HoleSpace
FIM2Y       = (SIZE (SIZE FIM2c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM2c  
LM2X        = ENCLOSE RECTANGLE FIM2Y MS_R_1_W MS_R_1_L
M2HoleD     = M2HoleSpace AND LM2X

MS.R.1.M2 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M2WideEXD = M2Wide7 NOT SLT_EXD
  X = (SIZE M2WideEXD BY MS_R_1_W_s UNDEROVER) AND M2WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M2HoleD LM2X

MS.DN.1.M2 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM2X M2HoleD < MS_DN_1
    [ AREA(M2HoleD) / AREA(LM2X) ] RDB M2Hole.density LM2X M2HoleD 
}

DISCONNECT

// MS.R.2.M2 is not able to check




//METAL3 SLOT CHECKS
//==================

M3EXD       = M3x NOT SLT_EXD
M3InnerHole = HOLES M3EXD INNER
M3BigHole   = SIZE M3InnerHole BY -5 	// Holes with width less than 10um will be filled back
M3Hole      = M3InnerHole OUTSIDE M3BigHole	
M3HoleSpace = M3Hole NOT M3EXD
FIM3c       = M3EXD OR M3HoleSpace
FIM3Y       = (SIZE (SIZE FIM3c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM3c  
LM3X        = ENCLOSE RECTANGLE FIM3Y MS_R_1_W MS_R_1_L
M3HoleD     = M3HoleSpace AND LM3X

MS.R.1.M3 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M3WideEXD = M3Wide7 NOT SLT_EXD
  X = (SIZE M3WideEXD BY MS_R_1_W_s UNDEROVER) AND M3WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M3HoleD LM3X

MS.DN.1.M3 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM3X M3HoleD < MS_DN_1
    [ AREA(M3HoleD) / AREA(LM3X) ] RDB M3Hole.density LM3X M3HoleD 
}

DISCONNECT

// MS.R.2.M3 is not able to check




//METAL4 SLOT CHECKS
//==================

M4EXD       = M4x NOT SLT_EXD
M4InnerHole = HOLES M4EXD INNER
M4BigHole   = SIZE M4InnerHole BY -5 	// Holes with width less than 10um will be filled back
M4Hole      = M4InnerHole OUTSIDE M4BigHole	
M4HoleSpace = M4Hole NOT M4EXD
FIM4c       = M4EXD OR M4HoleSpace
FIM4Y       = (SIZE (SIZE FIM4c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM4c  
LM4X        = ENCLOSE RECTANGLE FIM4Y MS_R_1_W MS_R_1_L
M4HoleD     = M4HoleSpace AND LM4X

MS.R.1.M4 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M4WideEXD = M4Wide7 NOT SLT_EXD
  X = (SIZE M4WideEXD BY MS_R_1_W_s UNDEROVER) AND M4WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M4HoleD LM4X

MS.DN.1.M4 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM4X M4HoleD < MS_DN_1
    [ AREA(M4HoleD) / AREA(LM4X) ] RDB M4Hole.density LM4X M4HoleD 
}

DISCONNECT

// MS.R.2.M4 is not able to check




//METAL5 SLOT CHECKS
//==================

M5EXD       = M5x NOT SLT_EXD
M5InnerHole = HOLES M5EXD INNER
M5BigHole   = SIZE M5InnerHole BY -5 	// Holes with width less than 10um will be filled back
M5Hole      = M5InnerHole OUTSIDE M5BigHole	
M5HoleSpace = M5Hole NOT M5EXD
FIM5c       = M5EXD OR M5HoleSpace
FIM5Y       = (SIZE (SIZE FIM5c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM5c  
LM5X        = ENCLOSE RECTANGLE FIM5Y MS_R_1_W MS_R_1_L
M5HoleD     = M5HoleSpace AND LM5X

MS.R.1.M5 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M5WideEXD = M5Wide7 NOT SLT_EXD
  X = (SIZE M5WideEXD BY MS_R_1_W_s UNDEROVER) AND M5WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M5HoleD LM5X

MS.DN.1.M5 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM5X M5HoleD < MS_DN_1
    [ AREA(M5HoleD) / AREA(LM5X) ] RDB M5Hole.density LM5X M5HoleD 
}

DISCONNECT

// MS.R.2.M5 is not able to check




//METAL6 SLOT CHECKS
//==================

M6EXD       = M6x NOT SLT_EXD
M6InnerHole = HOLES M6EXD INNER
M6BigHole   = SIZE M6InnerHole BY -5 	// Holes with width less than 10um will be filled back
M6Hole      = M6InnerHole OUTSIDE M6BigHole	
M6HoleSpace = M6Hole NOT M6EXD
FIM6c       = M6EXD OR M6HoleSpace
FIM6Y       = (SIZE (SIZE FIM6c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM6c  
LM6X        = ENCLOSE RECTANGLE FIM6Y MS_R_1_W MS_R_1_L
M6HoleD     = M6HoleSpace AND LM6X

MS.R.1.M6 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M6WideEXD = M6Wide7 NOT SLT_EXD
  X = (SIZE M6WideEXD BY MS_R_1_W_s UNDEROVER) AND M6WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M6HoleD LM6X

MS.DN.1.M6 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM6X M6HoleD < MS_DN_1
    [ AREA(M6HoleD) / AREA(LM6X) ] RDB M6Hole.density LM6X M6HoleD 
}

DISCONNECT

// MS.R.2.M6 is not able to check




//METAL7 SLOT CHECKS
//==================

#IFDEF CUP
M7EXD       = (M7x NOT SLT_EXD) NOT WBDMY
#ELSE
M7EXD       = M7x NOT SLT_EXD
#ENDIF
M7InnerHole = HOLES M7EXD INNER
M7BigHole   = SIZE M7InnerHole BY -5 	// Holes with width less than 10um will be filled back
M7Hole      = M7InnerHole OUTSIDE M7BigHole	
M7HoleSpace = M7Hole NOT M7EXD
FIM7c       = M7EXD OR M7HoleSpace
FIM7Y       = (SIZE (SIZE FIM7c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM7c  
LM7X        = ENCLOSE RECTANGLE FIM7Y MS_R_1_W MS_R_1_L
M7HoleD     = M7HoleSpace AND LM7X

MS.R.1.M7 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M7WideEXD = M7Wide7 NOT SLT_EXD
  X = (SIZE M7WideEXD BY MS_R_1_W_s UNDEROVER) AND M7WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M7HoleD LM7X

MS.DN.1.M7 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM7X M7HoleD < MS_DN_1
    [ AREA(M7HoleD) / AREA(LM7X) ] RDB M7Hole.density LM7X M7HoleD 
}

DISCONNECT

// MS.R.2.M7 is not able to check




//METAL8 SLOT CHECKS
//==================

// Bonding pad, chip corner dummy pad, and inductor need not put slot

#IFDEF CUP
SLT_EXD8    = (SLT_EXD OR WBDMY) OR INDDMY 		// For top metal only
#ELSE
PAD_EXD8    = SIZE PAD_EXD BY 5 INSIDE OF M8x STEP 0.32 
SLT_EXD8    = (SLT_EXD OR PAD_EXD8) OR INDDMY 		// For top metal only
#ENDIF

M8EXD       = M8x NOT SLT_EXD8
M8InnerHole = HOLES M8EXD INNER
M8BigHole   = SIZE M8InnerHole BY -5 	// Holes with width less than 10um will be filled back
M8Hole      = M8InnerHole OUTSIDE M8BigHole	
M8HoleSpace = M8Hole NOT M8EXD
FIM8c       = M8EXD OR M8HoleSpace
FIM8Y       = (SIZE (SIZE FIM8c BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIM8c  
LM8X        = ENCLOSE RECTANGLE FIM8Y MS_R_1_W MS_R_1_L
M8HoleD     = M8HoleSpace AND LM8X

MS.R.1.M8 { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  M8WideEXD = M8Wide7 NOT SLT_EXD8
  X = (SIZE M8WideEXD BY MS_R_1_W_s UNDEROVER) AND M8WideEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT M8HoleD LM8X

MS.DN.1.M8 { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LM8X M8HoleD < MS_DN_1
    [ AREA(M8HoleD) / AREA(LM8X) ] RDB M8Hole.density LM8X M8HoleD 
}

DISCONNECT

// MS.R.2.M8 is not able to check


//MD SLOT CHECKS
//==============

// Bonding pad, chip corner dummy pad, and inductor need not put slot

MDEXD       = MDx NOT ((LMARK OR CSRDMY) OR UBM_EXDD )
MDInnerHole = HOLES MDEXD INNER
MDBigHole   = SIZE MDInnerHole BY -5  	// Holes with width less than 10um will be filled back
MDHole      = MDInnerHole OUTSIDE MDBigHole	
MDHoleSpace = MDHole NOT MDEXD
FIMDc       = MDEXD OR MDHoleSpace
FIMDY       = (SIZE (SIZE FIMDc BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND FIMDc  
LMDX        = ENCLOSE RECTANGLE FIMDY MS_R_1_W MS_R_1_L
MDHoleD     = MDHoleSpace AND LMDX

MS.R.1.MD { @ Metal slots are required for wide metal lines. Wide metal is defined as metal that is >= 12 um in width and >= 30 um in length. Only bonding/bump pad areas are excluded.   
  X = (SIZE (SIZE MDEXD BY 1.0 UNDEROVER) BY MS_R_1_W_s UNDEROVER) AND MDEXD
  ENCLOSE RECTANGLE X MS_R_1_W MS_R_1_L
}

CONNECT MDHoleD LMDX

MS.DN.1.MD { @ Metal hole density ( Maximum metal density 91%) for the wide metal. Metal holes with a width or length <= 10 um are ignored and treated as metal. in identifying wide metal (>= 12 um x 30 um). 9%  
  NET AREA RATIO LMDX MDHoleD < MS_DN_1
    [ AREA(MDHoleD) / AREA(LMDX) ] RDB MDHole.density LMDX MDHoleD 
}

DISCONNECT

// MS.R.2.MD is not able to check




//NW CHECKS
//=========

HOT_NWEL = (NWEL AND HOTWL) OR RNWEL
HOT_NW1V = NW1V  AND HOTWL
HOT_NW2V = NW2V  AND HOTWL

RWi = DNWELLi NOT NWELLi

CONNECT NSTPi NWELLi    
CONNECT NSTPi PSDi
CONNECT PSTPi NSDi
CONNECT PSTPi RWi
CONNECT NWEL DNW
CONNECT M1x ILP1i NSTPi PSTPi PSDi NSDi BY CONTi
CONNECT M1x M2x BY VIA12i
CONNECT M2x M3x BY VIA23i
CONNECT M3x M4x BY VIA34i
CONNECT M4x M5x BY VIA45i
CONNECT M5x M6x BY VIA56i
CONNECT M6x M7x BY VIA67i
CONNECT M7x M8x BY VIA78i
CONNECT M8x MDx BY VIADi

#IFDEF SUGGESTED

NW1Vs = NWEL OUTSIDE OD2
NW2Vs = NWEL NOT OUTSIDE OD2

SUGGESTED.NW.S.3 { @ More conservative way to check NW.S.3 as DRC can not determine the
		   @ operating voltages of nwels.
  EXT NW1Vs NW2Vs < 1.2 ABUT < 90 > 0 SINGULAR
}
SUGGESTED.NW.S.4 { @ More conservative way to check NW.S.4 as DRC can not determine the
		   @ operating voltages of nwels.
  NW2V_NODALs = STAMP NW2Vs BY NWELLi
  EXT NW2V_NODALs < 1.2 ABUT < 90 SPACE NOT CONNECTED SINGULAR
}

#ENDIF

NW.W.1 { @ Width >= 0.620 
  (INT NWEL < 0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.W.2 { @ Width of {NW interact with HOTWL} Please use dummy layer HOTWL to fully cover this NW for DRC checking. >= 1.800 
  (INT HOT_NWEL < 1.8 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.1 { @ Space >= 0.620 
  (EXT NWEL < 0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.2 { @ Space of two NW1V with different potentials. [The maximum applied voltage = 1.2V.] >= 1.000 
  NW1V_NODAL = STAMP NW1V BY NWELLi
  (EXT NW1V_NODAL < 1.0 ABUT < 90 SPACE NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.3 { @ NW1V space to NW2V >= 1.200 
  (EXT NW1V NW2V < 1.2 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.S.4 { @ Space of two NW2V with different potentials. [1.2V < maximum applied voltage <= 2.5V (or 3.3V)] >= 1.200 
  NW2V_NODAL = STAMP NW2V BY NWELLi
  (EXT NW2V_NODAL < 1.2 ABUT < 90 SPACE NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}
NW.A.1 { @ Area >= 1.000 
  AREA NWEL < 1.0
}
NW.A.2 { @ Enclosed area >= 0.384 
  (HOLES NWEL < 0.384 INNER) NOT INSIDE EXCL_SRM
}  



//NW Resistor CHECKS
//==================

// For NW within OD (NWROD) resistor 

NWRES     = RNWEL   INTERACT RPO	// NW resistor (within OD)
NPWR      = NP      INTERACT NWRES	// N+ implant on NW resistor terminals
COWR      = COOD    INTERACT NWRES	// Contact on NW resistor terminals
RHWR      = ODWR    NOT RPO		// Silicided area of NW resistor    

NWROD.W.1 { @ Width >= 1.80 
  INT RNWEL < 1.8 ABUT < 90 SINGULAR REGION
}
NWROD.S.1 { @ Space to NWROD or to NW >= 1.20 
  EXT RNWEL < 1.2 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < 1.2 ABUT < 90 SINGULAR
}
NWROD.S.2 { @ Space to RPO >= 0.30 
  EXT NWRES RPO < 0.3 ABUT < 90 SINGULAR
}
NWROD.EN.1 { @ Enclosure by OD >= 1.00 
  ENC NWRES ODWR < 1.0 ABUT < 90 OVERLAP SINGULAR
}
NWROD.EN.2 { @ Enclosure of CO >= 0.30 
  ENC COWR NWRES < 0.3 ABUT < 90 OVERLAP SINGULAR
}
NWROD.EX.1 { @ RPO extension on OD >= 0.22 
  ENC ODWR RPO < 0.22 ABUT < 90 SINGULAR 
  (ODWR INTERACT RPO) OUTSIDE EDGE RPO
}
NWROD.O.1 { @ RPO overlap of NP >= 0.40 
  INT NPWR RPO < 0.4 ABUT < 90 SINGULAR REGION
  X = RPO INTERACT NWRES
  H = HOLES X INNER
  H NOT NPWR
}
NWROD.O.2 { @ {OD AND NWDMY} overlap of PP, NP, VTL_N, VTL_P, VTH_N or VTH_P is not allowed.   
  NWROD = NWDMY AND OD
  NWROD AND NP
  NWROD AND PP
  NWROD AND VTLN
  NWROD AND VTLP
  NWROD AND VTHN
  NWROD AND VTHP
}

// For NW under STI (NWRSTI) resistor

NWRES_STI = RNWEL   NOT INTERACT RPO	// NW resistor (under STI)
ODWR_STI  = OD      INTERACT NWRES_STI
NPWR_STI  = NP      INTERACT NWRES_STI

// NWRSTI.W.1 is checked by NWROD.W.1
// NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.3 { @ NP enclosure of OD >= 0.18 
  ENC ODWR_STI NPWR_STI < 0.18 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}


//DNW CHECKS
//==========

DNW.W.1 { @ Width >= 3.00 
  (INT DNW < 3.0 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.S.1 { @ Space >= 5.00 
  (EXT DNW < 5.0 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.S.2 { @ Space to NW >= 3.50 
    (EXT DNW NWEL < DNW_S_2  ABUT <90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE EXCL_SRM
}

RW = DNW NOT NWEL
RW1V = RW NOT INTERACT OD2
RW2V = RW INTERACT OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi


DNW.S.3 { @ RW space to RW with different potential >= 1.00 
  (EXT RW1V_NODAL < 1.0 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}

DNW.S.4 { @ RW space to {RW interact with OD2} with different potential	>=	1.2	
  (EXT RW2V_NODAL < 1.2 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
  (EXT RW2V_NODAL RW1V_NODAL < 1.2 ABUT <90 NOT CONNECTED SINGULAR REGION) NOT INSIDE EXCL_SRM
}

DNW.EN.1 { @ Enclosure by NW >= 1.50 
  (ENC DNW NWEL < 1.5 ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.O.1 { @ Overlap of NW >= 2.00 
  (INT DNW NWEL < 2.0  ABUT < 90 SINGULAR REGION) NOT INSIDE EXCL_SRM
}
DNW.R.1 { @ Each DNW edge must be enclosed by NW   
  DNW_out_VAR = DNW OUTSIDE VARDMY
  DNW_out_VAR OUTSIDE EDGE NWEL
}

// DNW.R.2 is not able to check



//CO CHECKS
//=========

PSTP_NACT_BTE  = PSTP COIN OUTSIDE EDGE NACT     
NACT_PSTP_BTE  = NACT COIN OUTSIDE EDGE PSTP
NSTP_PACT_BTE  = NSTP COIN OUTSIDE EDGE PACT
PACT_NSTP_BTE  = PACT COIN OUTSIDE EDGE NSTP     

CO.W.1 { @ Width (maximum = minimum) = 0.16 
  A = NOT RECTANGLE CO == 0.16 BY == 0.16 ORTHOGONAL ONLY
  (A NOT VIA_EXD) NOT SR_M1
}
CO.S.1 { @ Space >= 0.18 
  EXT CO < 0.18 ABUT < 90 SINGULAR REGION
}
CO.S.2 { @ Space in CO array [CO number >= 4 x 4 (row and column >= 4) with space <=0.21 um] >= 0.20 
  COMerge = SIZE CO BY 0.21 / 2 OVERUNDER  // space <= 0.21 um treated as array
  // ( ( 4 - 1 ) * 0.16 + ( 4 - 2 ) * 0.21 ) / 2 ) = 0.45
  MinArray = SIZE COMerge BY 0.45 UNDEROVER
  // get array larger than or equal to 4 x 4 
  COArray = MinArray INTERACT CO >= 4 * 4
  COInArray = CO INTERACT COArray
  EXT COInArray < 0.20 ABUT < 90 REGION
}
CO.S.3 { @ {CO inside OD} space to 1.0V, 1.2V, or 2.5V GATE >= 0.11 
  EXT COOD GATE < 0.11 ABUT < 90 INSIDE ALSO SINGULAR
}

#IFDEF 3.3V
CO.S.4 { @ {CO inside OD} space to 3.3V GATE >= 0.13 
  EXT COOD HV_GATE < 0.13 ABUT < 90 INSIDE ALSO SINGULAR
}
#ENDIF

CO.S.5 { @ {CO inside PO} space to OD >= 0.14 
  EXT COPO OD < 0.14 ABUT < 90 INSIDE ALSO SINGULAR
}
CO.EN.1 { @ Enclosure by ACTIVE >= 0.07 
  ENC COOD DACT < 0.07 ABUT < 90 SINGULAR
}
CO.EN.2 { @ Enclosure by PO >= 0.07 
  ENC COPO POLY < 0.07 ABUT < 90 SINGULAR
}
CO.EN.3 { @ Enclosure by butted PP on OD >= 0.09 
  EXT NACT_PSTP_BTE COOD < 0.09 ABUT < 90
  EXT NSTP_PACT_BTE COOD < 0.09 ABUT < 90
  COOD CUT PP
  ENC COOD PP < 0.001 ABUT < 90 SINGULAR
}
CO.EN.4 { @ Enclosure by butted NP on OD >= 0.09 
  EXT PACT_NSTP_BTE COOD < 0.09 ABUT < 90
  EXT PSTP_NACT_BTE COOD < 0.09 ABUT < 90
  COOD CUT NP
  ENC COOD NP < 0.001 ABUT < 90 SINGULAR
}
CO.EN.5 { @ Enclosure by STRAP >= 0.05 
  ENC COOD DSTP < 0.05 ABUT < 90 SINGULAR
}

// CO.R.1 is checked by CO.S.3/CO.S.5
// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1

CO.R.6 { @ {CO outside OD} or {CO outside Poly} is not allowed.   
  (CO NOT ODi) NOT POLYGi
}


//BACKEND RULES 
//=============

// for metal stack rules
// metal overlap area is formed by 3 adjacent metal levels

M1Stack   = (SIZE M1Wide7 BY 1.1) AND M1

M2Stack   = (SIZE M2Wide7 BY 1.1) AND M2

//M1 CHECKS
//=========

M1_EDGE_45  = M1 ANGLE == 45
M1_EDGE_45L = LENGTH M1_EDGE_45 >= 0.50

M1.W.1 { @ Width. >= 0.160 
  INT M1 < 0.16 ABUT < 90 SINGULAR REGION
}
M1.W.2 { @ Width of 45-degree bent M1 [length >= 0.5 um] >= 0.200 
  INT M1_EDGE_45L < 0.20 ABUT < 90 REGION
}
M1.S.1 { @ Space >= 0.180 
  EXT M1 < 0.18 ABUT < 90 SINGULAR REGION
}

M1.S.2 { @ Space to wide M1 (both metal line width and length > 10 um), or wide M1 branch (a small piece of metal connected to a wide metal) within the <= 1.0 um range from the wide M1 >= 0.600 
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_Exp = SIZE M1_Wide BY 1 INSIDE OF M1 STEP 0.126
  M1_Branch = M1_Exp NOT M1_Wide
  M1_Branch_edge = M1_Branch COIN INSIDE EDGE M1
  M1_Check = M1 AND (SIZE M1_Exp BY 0.6)
  M1_Else = M1_Check NOT INTERACT M1_Exp
  M1_Extend = M1_Check NOT M1_Exp 
  M1_WideC = STAMP M1_Wide BY M1x
  M1_ElseC = STAMP M1_Check BY M1x
  EXT M1_WideC M1_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M1_Branch_edge M1_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M1_Branch_edge M1_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M1_Branch_edge M1_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M1_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M1_Extend
}

M1.S.3 { @ Space [for at least one metal line width >= 0.3 um and the parallel (projective) metal run length >= 1 um] >= 0.220 
  X = EXT M1Wide0.3 M1 < 0.22 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M1Wide0.3
  PATH LENGTH WideEdge >= 1
}

M1.S.4 { @ Space to 45-degree bent M1 [for 45-degree bent M1 length >= 0.5 um] >= 0.220 
  X = EXPAND EDGE M1_EDGE_45L OUTSIDE BY 0.22
  X AND M1
}
M1.EN.1 { @ Enclosure of CO >= 0.000 
  CO NOT M1
}
M1.EN.2 { @ Enclosure of CO [at least two opposite sides] For CO located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line and another side can follow the M1.EN.1rule. >= 0.050 
  X = RECTANGLE ENCLOSURE CO M1 ABUT > 0 < 90 GOOD 0.0 0.05 OPPOSITE 0.0 0.05 OPPOSITE
  Y = ENC [X] M1 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.16 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M1.A.1 { @ Area >= 0.122 
  AREA M1 < 0.122
}
M1.A.2 { @ Enclosed area >= 0.200 
  HOLES M1 < 0.2 INNER
}  

//VIA1 CHECKS
//===========

VIA1.W.1 { @ Width (maximum = minimum) = 0.190 
  A = NOT RECTANGLE VIA1 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA1.S.1 { @ Space >= 0.220 
  EXT VIA1 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA1.S.2 { @ Space in VIA1 array [VIA1 number >= 3 x 3 (row and column >= 3) with space <= 0.31 um] >= 0.290 
  VIA1Merge = SIZE VIA1 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA1Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA1Array = MinArray INTERACT VIA1 >= 3 * 3
  VIA1InArray = VIA1 INTERACT VIA1Array
  EXT VIA1InArray < 0.29 ABUT < 90 REGION
}
VIA1.EN.1 { @ Enclosure by M1 >= 0.010 
  ENC VIA1 M1 < 0.01 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA1.EN.2 { @ Enclosure by M1 [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA1 M1 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M1 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA1.R.1 is checked by VIA1.W.1

VIA1.R.2 { @ At least two VIA1s, with space <= 0.71 um, are required to connect M1 and M2, if either M1 or M2 has both width and length >1.4 um. If four VIA1s are used, the space must be <= 1 um..   
  M2OvpM1W = (M2 AND M1Wide1.4) OR (M1 AND M2Wide1.4)
  m1_has_wm_ovp = METAL1i INTERACT M2OvpM1W
  m2_has_wm_ovp = METAL2i INTERACT M2OvpM1W
  MOvp = m1_has_wm_ovp AND m2_has_wm_ovp 
  VIA_EXC = VIA1 NOT VIA_EXD
  M12Wide = M1Wide1.4 OR M2Wide1.4
  OvpOnM12W = MOvp NOT OUTSIDE M12Wide
  VIA_Check1 = VIA_EXC INTERACT OvpOnM12W 
  
  Merge1OnM12W = SIZE VIA_Check1 BY 0.71/2 INSIDE OF OvpOnM12W STEP 0.18*0.7
  badRegion1  = Merge1OnM12W INTERACT VIA_Check1 < 2
  GoodRegion1 = Merge1OnM12W OUTSIDE badRegion1
  Merge2OnM12W = SIZE Merge1OnM12W BY (1 - 0.71)/2 INSIDE OF OvpOnM12W STEP 0.18*0.7
  badRegion2  = Merge2OnM12W INTERACT VIA_Check1 < 4
  GoodRegion2 = Merge2OnM12W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check1 INTERACT GoodRegion) NOT OUTSIDE M12Wide
  M12Check = (M12Wide AND OvpOnM12W) NOT INTERACT GoodVIA
  VIA_Check1 NOT OUTSIDE M12Check 
}  


M3Stack   = (SIZE M3Wide7 BY 1.1) AND M3
M3OvpM2   = M3Stack AND M2Stack
M2Overlap = M3OvpM2 AND M1Stack


//M2 CHECKS
//=========

M2_EDGE_45 = M2 ANGLE == 45
M2_EDGE_45L = LENGTH M2_EDGE_45 >= 0.50

M2.W.1 { @ Width >= 0.200 
  INT M2 < 0.20 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M2_EDGE_45L < 0.24 ABUT < 90 REGION
}
M2.S.1 { @ Space >= 0.210 
  EXT M2 < 0.21 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_Exp = SIZE M2_Wide BY 1 INSIDE OF M2 STEP 0.147
  M2_Branch = M2_Exp NOT M2_Wide
  M2_Branch_edge = M2_Branch COIN INSIDE EDGE M2
  M2_Check = M2 AND (SIZE M2_Exp BY 0.6)
  M2_Else = M2_Check NOT INTERACT M2_Exp
  M2_Extend = M2_Check NOT M2_Exp 
  M2_WideC = STAMP M2_Wide BY M2x
  M2_ElseC = STAMP M2_Check BY M2x
  EXT M2_WideC M2_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M2_Branch_edge M2_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M2_Branch_edge M2_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M2_Branch_edge M2_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M2_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M2_Extend
}
M2.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M2Wide0.4 M2 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M2Wide0.4
  PATH LENGTH WideEdge >= 1
}
M2.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M2_EDGE_45L OUTSIDE BY 0.24
  X AND M2
}
M2.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA1 M2 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M2.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA1 M2 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M2 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M2.A.1 { @ Area >= 0.144 
  AREA M2 < 0.144
}
M2.A.2 { @ Enclosed area >= 0.265 
  HOLES M2 < 0.265 INNER
}  

M2.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M2OverlapBig = (SIZE M2Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M2Overlap
  W = EXT M2OverlapBig M2Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M1
  Y = X NOT INSIDE M2
  Y1 = Y NOT INSIDE M3
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M4Stack   = (SIZE M4Wide7 BY 1.1) AND M4
M3Overlap = M3OvpM2 AND M4Stack


//M3 CHECKS
//=========

M3_EDGE_45 = M3 ANGLE == 45
M3_EDGE_45L = LENGTH M3_EDGE_45 >= 0.50

M3.W.1 { @ Width >= 0.200 
  INT M3 < 0.20 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M3_EDGE_45L < 0.24 ABUT < 90 REGION
}
M3.S.1 { @ Space >= 0.210 
  EXT M3 < 0.21 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_Exp = SIZE M3_Wide BY 1 INSIDE OF M3 STEP 0.147
  M3_Branch = M3_Exp NOT M3_Wide
  M3_Branch_edge = M3_Branch COIN INSIDE EDGE M3
  M3_Check = M3 AND (SIZE M3_Exp BY 0.6)
  M3_Else = M3_Check NOT INTERACT M3_Exp
  M3_Extend = M3_Check NOT M3_Exp 
  M3_WideC = STAMP M3_Wide BY M3x
  M3_ElseC = STAMP M3_Check BY M3x
  EXT M3_WideC M3_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M3_Branch_edge M3_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M3_Branch_edge M3_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M3_Branch_edge M3_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M3_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M3_Extend
}
M3.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M3Wide0.4 M3 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M3Wide0.4
  PATH LENGTH WideEdge >= 1
}
M3.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M3_EDGE_45L OUTSIDE BY 0.24
  X AND M3
}
M3.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA2 M3 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M3.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA2 M3 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M3 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M3.A.1 { @ Area >= 0.144 
  AREA M3 < 0.144
}
M3.A.2 { @ Enclosed area >= 0.265 
  HOLES M3 < 0.265 INNER
}  

M3.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M3OverlapBig = (SIZE M3Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M3Overlap
  W = EXT M3OverlapBig M3Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M2
  Y = X NOT INSIDE M3
  Y1 = Y NOT INSIDE M4
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M5Wide1.8 = (SIZE M5Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M5Wide1.4
M5Stack   = (SIZE M5Wide7 BY 1.1) AND M5
M5OvpM4   = M5Stack AND M4Stack
M4Overlap = M5OvpM4 AND M3Stack


//M4 CHECKS
//=========

M4_EDGE_45 = M4 ANGLE == 45
M4_EDGE_45L = LENGTH M4_EDGE_45 >= 0.50

M4.W.1 { @ Width >= 0.200 
  INT M4 < 0.20 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M4_EDGE_45L < 0.24 ABUT < 90 REGION
}
M4.S.1 { @ Space >= 0.210 
  EXT M4 < 0.21 ABUT < 90 SINGULAR REGION
}
M4.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_Exp = SIZE M4_Wide BY 1 INSIDE OF M4 STEP 0.147
  M4_Branch = M4_Exp NOT M4_Wide
  M4_Branch_edge = M4_Branch COIN INSIDE EDGE M4
  M4_Check = M4 AND (SIZE M4_Exp BY 0.6)
  M4_Else = M4_Check NOT INTERACT M4_Exp
  M4_Extend = M4_Check NOT M4_Exp 
  M4_WideC = STAMP M4_Wide BY M4x
  M4_ElseC = STAMP M4_Check BY M4x
  EXT M4_WideC M4_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M4_Branch_edge M4_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M4_Branch_edge M4_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M4_Branch_edge M4_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M4_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M4_Extend
}
M4.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M4Wide0.4 M4 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M4Wide0.4
  PATH LENGTH WideEdge >= 1
}
M4.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M4_EDGE_45L OUTSIDE BY 0.24
  X AND M4
}
M4.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA3 M4 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M4.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA3 M4 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M4 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M4.A.1 { @ Area >= 0.144 
  AREA M4 < 0.144
}
M4.A.2 { @ Enclosed area >= 0.265 
  HOLES M4 < 0.265 INNER
}  

M4.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M4OverlapBig = (SIZE M4Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M4Overlap
  W = EXT M4OverlapBig M4Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M3
  Y = X NOT INSIDE M4
  Y1 = Y NOT INSIDE M5
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M6Wide1.8 = (SIZE M6Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M6Wide1.4
M6Stack   = (SIZE M6Wide7 BY 1.1) AND M6
M5Overlap = M5OvpM4 AND M6Stack


//M5 CHECKS
//=========

M5_EDGE_45 = M5 ANGLE == 45
M5_EDGE_45L = LENGTH M5_EDGE_45 >= 0.50

M5.W.1 { @ Width >= 0.200 
  INT M5 < 0.20 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M5_EDGE_45L < 0.24 ABUT < 90 REGION
}
M5.S.1 { @ Space >= 0.210 
  EXT M5 < 0.21 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_Exp = SIZE M5_Wide BY 1 INSIDE OF M5 STEP 0.147
  M5_Branch = M5_Exp NOT M5_Wide
  M5_Branch_edge = M5_Branch COIN INSIDE EDGE M5
  M5_Check = M5 AND (SIZE M5_Exp BY 0.6)
  M5_Else = M5_Check NOT INTERACT M5_Exp
  M5_Extend = M5_Check NOT M5_Exp 
  M5_WideC = STAMP M5_Wide BY M5x
  M5_ElseC = STAMP M5_Check BY M5x
  EXT M5_WideC M5_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M5_Branch_edge M5_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M5_Branch_edge M5_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M5_Branch_edge M5_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M5_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M5_Extend
}
M5.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M5Wide0.4 M5 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M5Wide0.4
  PATH LENGTH WideEdge >= 1
}
M5.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M5_EDGE_45L OUTSIDE BY 0.24
  X AND M5
}
M5.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA4 M5 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M5.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA4 M5 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M5 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M5.A.1 { @ Area >= 0.144 
  AREA M5 < 0.144
}
M5.A.2 { @ Enclosed area >= 0.265 
  HOLES M5 < 0.265 INNER
}  

M5.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M5OverlapBig = (SIZE M5Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M5Overlap
  W = EXT M5OverlapBig M5Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M4
  Y = X NOT INSIDE M5
  Y1 = Y NOT INSIDE M6
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M7Wide1.8 = (SIZE M7Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M7Wide1.4
M7Stack   = (SIZE M7Wide7 BY 1.1) AND M7
M7OvpM6   = M7Stack AND M6Stack
M6Overlap = M7OvpM6 AND M5Stack

#IFDEF THICK_TOP3_METAL

//THICK M6 CHECKS
//=============


M6.W.1.THICK { @ Width >= 0.400 
  INT M6 < 0.4 ABUT < 90 SINGULAR REGION
}
M6.S.1.THICK { @ Space >= 0.420 
  EXT M6 < 0.42 ABUT < 90 SINGULAR REGION
}
M6.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY 1 INSIDE OF M6 STEP 0.294
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY 0.6)
  M6_Else = M6_Check NOT INTERACT M6_Exp
  M6_Extend = M6_Check NOT M6_Exp 
  M6_WideC = STAMP M6_Wide BY M6x
  M6_ElseC = STAMP M6_Check BY M6x
  EXT M6_WideC M6_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M6_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M6_Extend
}
M6.EN.1.THICK { @ Enclosure of VIA5 >= 0.020 
  ENC VIA5 M6 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M6.EN.2.THICK { @ Enclosure of VIA5 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA5 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA5 M6 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M6 < 0.09 ABUT < 90 SINGULAR REGION
}
M6.A.1.THICK { @ Area >= 0.562 
  AREA M6 < 0.562
}
M6.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M6 < 0.565 INNER
}  

#ELSE

//M6 CHECKS
//=========

M6_EDGE_45 = M6 ANGLE == 45
M6_EDGE_45L = LENGTH M6_EDGE_45 >= 0.50

M6.W.1 { @ Width >= 0.200 
  INT M6 < 0.20 ABUT < 90 SINGULAR REGION
}
M6.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M6_EDGE_45L < 0.24 ABUT < 90 REGION
}
M6.S.1 { @ Space >= 0.210 
  EXT M6 < 0.21 ABUT < 90 SINGULAR REGION
}
M6.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY 1 INSIDE OF M6 STEP 0.147
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY 0.6)
  M6_Else = M6_Check NOT INTERACT M6_Exp
  M6_Extend = M6_Check NOT M6_Exp 
  M6_WideC = STAMP M6_Wide BY M6x
  M6_ElseC = STAMP M6_Check BY M6x
  EXT M6_WideC M6_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M6_Branch_edge M6_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M6_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M6_Extend
}
M6.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M6Wide0.4 M6 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M6Wide0.4
  PATH LENGTH WideEdge >= 1
}
M6.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M6_EDGE_45L OUTSIDE BY 0.24
  X AND M6
}
M6.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA5 M6 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M6.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA5 M6 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M6 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M6.A.1 { @ Area >= 0.144 
  AREA M6 < 0.144
}
M6.A.2 { @ Enclosed area >= 0.265 
  HOLES M6 < 0.265 INNER
}  
#ENDIF

M6.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M6OverlapBig = (SIZE M6Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M6Overlap
  W = EXT M6OverlapBig M6Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M5
  Y = X NOT INSIDE M6
  Y1 = Y NOT INSIDE M7
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}


M8Wide1.8 = (SIZE M8Wide1.4 BY 0.9 UNDEROVER TRUNCATE 0.9) AND M8Wide1.4
M8Stack   = (SIZE M8Wide7 BY 1.1) AND M8
M7Overlap = M7OvpM6 AND M8Stack

#IFDEF THICK_TOP2_METAL

//THICK M7 CHECKS
//=============


M7.W.1.THICK { @ Width >= 0.400 
  INT M7 < 0.4 ABUT < 90 SINGULAR REGION
}
M7.S.1.THICK { @ Space >= 0.420 
  EXT M7 < 0.42 ABUT < 90 SINGULAR REGION
}
M7.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY 1 INSIDE OF M7 STEP 0.294
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY 0.6)
  M7_Else = M7_Check NOT INTERACT M7_Exp
  M7_Extend = M7_Check NOT M7_Exp 
  M7_WideC = STAMP M7_Wide BY M7x
  M7_ElseC = STAMP M7_Check BY M7x
  EXT M7_WideC M7_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M7_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M7_Extend
}
M7.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M7 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M7.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M7 < 0.09 ABUT < 90 SINGULAR REGION
}
M7.A.1.THICK { @ Area >= 0.562 
  AREA M7 < 0.562
}
M7.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M7 < 0.565 INNER
}  

#ELSE
#IFDEF THICK_TOP3_METAL

//THICK M7 CHECKS
//=============


M7.W.1.THICK { @ Width >= 0.400 
  INT M7 < 0.4 ABUT < 90 SINGULAR REGION
}
M7.S.1.THICK { @ Space >= 0.420 
  EXT M7 < 0.42 ABUT < 90 SINGULAR REGION
}
M7.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY 1 INSIDE OF M7 STEP 0.294
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY 0.6)
  M7_Else = M7_Check NOT INTERACT M7_Exp
  M7_Extend = M7_Check NOT M7_Exp 
  M7_WideC = STAMP M7_Wide BY M7x
  M7_ElseC = STAMP M7_Check BY M7x
  EXT M7_WideC M7_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M7_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M7_Extend
}
M7.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M7 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M7.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M7 < 0.09 ABUT < 90 SINGULAR REGION
}
M7.A.1.THICK { @ Area >= 0.562 
  AREA M7 < 0.562
}
M7.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M7 < 0.565 INNER
}  

#ELSE

//M7 CHECKS
//=========

M7_EDGE_45 = M7 ANGLE == 45
M7_EDGE_45L = LENGTH M7_EDGE_45 >= 0.50

M7.W.1 { @ Width >= 0.200 
  INT M7 < 0.20 ABUT < 90 SINGULAR REGION
}
M7.W.2 { @ Width of 45-degree bent Mx [length >= 0.5 um] >= 0.240 
  INT M7_EDGE_45L < 0.24 ABUT < 90 REGION
}
M7.S.1 { @ Space >= 0.210 
  EXT M7 < 0.21 ABUT < 90 SINGULAR REGION
}
M7.S.2 { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M7_S5 = SHRINK (SHRINK (SHRINK (SHRINK M7Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_G5 = GROW (GROW (GROW (GROW M7_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M7_Wide = M7_G5 AND M7
  M7_Exp = SIZE M7_Wide BY 1 INSIDE OF M7 STEP 0.147
  M7_Branch = M7_Exp NOT M7_Wide
  M7_Branch_edge = M7_Branch COIN INSIDE EDGE M7
  M7_Check = M7 AND (SIZE M7_Exp BY 0.6)
  M7_Else = M7_Check NOT INTERACT M7_Exp
  M7_Extend = M7_Check NOT M7_Exp 
  M7_WideC = STAMP M7_Wide BY M7x
  M7_ElseC = STAMP M7_Check BY M7x
  EXT M7_WideC M7_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M7_Branch_edge M7_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M7_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M7_Extend
}
M7.S.3 { @ Space [for at least one metal line width >= 0.39 um and the parallel (projective) run length >= 1 um] >= 0.240 
  X = EXT M7Wide0.4 M7 < 0.24 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X 0.005 1.00
  WideEdge = Y COIN OUTSIDE EDGE M7Wide0.4
  PATH LENGTH WideEdge >= 1
}
M7.S.4 { @ Space to 45-degree bent Mx [45-degree bent Mx length >= 0.5 um] >= 0.240 
  X = EXPAND EDGE M7_EDGE_45L OUTSIDE BY 0.24
  X AND M7
}
M7.EN.1 { @ Enclosure of VIAx-1 >= 0.005 
  ENC VIA6 M7 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
M7.EN.2 { @ Enclosure of VIAx-1 [at least two opposite sides] For VIAx-1 located at the 90-degree corner, at least one side of the metal enclosure must be treated as the end-of-line; another side can follow Mx.EN.1.  Refer to the figure in this section. >= 0.050 
  X = RECTANGLE ENCLOSURE VIA6 M7 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M7 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
M7.A.1 { @ Area >= 0.144 
  AREA M7 < 0.144
}
M7.A.2 { @ Enclosed area >= 0.265 
  HOLES M7 < 0.265 INNER
}  
#ENDIF
#ENDIF

M7.S.5 { @ Space of two adjacent stacked metal (metal layers >= 3) [both length and width of (either A or B) > 7 um, and the projection length (L) > 7 um] The stacked metal layers >= 3 mean that the overlapped area contains >= 3 consecutive metal layers. (For example: M1/M2/M3, or M4/M5/M6 , and so on) >= 1.000 
  M7OverlapBig = (SIZE M7Overlap BY 3.5 UNDEROVER TRUNCATE 3.5) AND M7Overlap
  W = EXT M7OverlapBig M7Overlap < 1 OPPOSITE MEASURE ALL REGION
  X = W NOT INSIDE M6
  Y = X NOT INSIDE M7
  Y1 = Y NOT INSIDE M8
  ENCLOSE RECTANGLE Y1 0.005 7.005 
}



//VIA2 CHECKS
//===========

VIA2.W.1 { @ Width (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA2 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA2.S.1 { @ Space >= 0.220 
  EXT VIA2 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA2.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA2Merge = SIZE VIA2 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA2Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA2Array = MinArray INTERACT VIA2 >= 3 * 3
  VIA2InArray = VIA2 INTERACT VIA2Array
  EXT VIA2InArray < 0.29 ABUT < 90 REGION
}
VIA2.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA2 M2 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA2.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA2 M2 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M2 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA2.R.1 is checked by VIA2.W.1

VIA2.R.2 { @ At least two VIAxs, with space <= 0.71 um, are required to connect Mx and Mx+1, if either Mx or Mx+1 has both width and length >1.4 um. If four VIAxs are used, the space must be <= 1 um.   
  M3OvpM2W = (M3 AND M2Wide1.4) OR (M2 AND M3Wide1.4)
  m2_has_wm_ovp = METAL2i INTERACT M3OvpM2W
  m3_has_wm_ovp = METAL3i INTERACT M3OvpM2W
  MOvp = m2_has_wm_ovp AND m3_has_wm_ovp 
  VIA_EXC = VIA2 NOT VIA_EXD
  M23Wide = M2Wide1.4 OR M3Wide1.4
  OvpOnM23W = MOvp NOT OUTSIDE M23Wide
  VIA_Check2 = VIA_EXC INTERACT OvpOnM23W 
  
  Merge1OnM23W = SIZE VIA_Check2 BY 0.71/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion1  = Merge1OnM23W INTERACT VIA_Check2 < 2
  GoodRegion1 = Merge1OnM23W OUTSIDE badRegion1
  Merge2OnM23W = SIZE Merge1OnM23W BY (1 - 0.71)/2 INSIDE OF OvpOnM23W STEP 0.21*0.7
  badRegion2  = Merge2OnM23W INTERACT VIA_Check2 < 4
  GoodRegion2 = Merge2OnM23W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check2 INTERACT GoodRegion) NOT OUTSIDE M23Wide
  M23Check = (M23Wide AND OvpOnM23W) NOT INTERACT GoodVIA
  VIA_Check2 NOT OUTSIDE M23Check 
}    


//VIA3 CHECKS
//===========

VIA3.W.1 { @ Width (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA3 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA3.S.1 { @ Space >= 0.220 
  EXT VIA3 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA3.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA3Merge = SIZE VIA3 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA3Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA3Array = MinArray INTERACT VIA3 >= 3 * 3
  VIA3InArray = VIA3 INTERACT VIA3Array
  EXT VIA3InArray < 0.29 ABUT < 90 REGION
}
VIA3.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA3 M3 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA3.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA3 M3 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M3 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA3.R.1 is checked by VIA3.W.1

VIA3.R.2 { @ At least two VIAxs, with space <= 0.71 um, are required to connect Mx and Mx+1, if either Mx or Mx+1 has both width and length >1.4 um. If four VIAxs are used, the space must be <= 1 um.   
  M4OvpM3W = (M4 AND M3Wide1.4) OR (M3 AND M4Wide1.4)
  m3_has_wm_ovp = METAL3i INTERACT M4OvpM3W
  m4_has_wm_ovp = METAL4i INTERACT M4OvpM3W
  MOvp = m3_has_wm_ovp AND m4_has_wm_ovp 
  VIA_EXC = VIA3 NOT VIA_EXD
  M34Wide = M3Wide1.4 OR M4Wide1.4
  OvpOnM34W = MOvp NOT OUTSIDE M34Wide
  VIA_Check3 = VIA_EXC INTERACT OvpOnM34W 
  
  Merge1OnM34W = SIZE VIA_Check3 BY 0.71/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion1  = Merge1OnM34W INTERACT VIA_Check3 < 2
  GoodRegion1 = Merge1OnM34W OUTSIDE badRegion1
  Merge2OnM34W = SIZE Merge1OnM34W BY (1 - 0.71)/2 INSIDE OF OvpOnM34W STEP 0.21*0.7
  badRegion2  = Merge2OnM34W INTERACT VIA_Check3 < 4
  GoodRegion2 = Merge2OnM34W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check3 INTERACT GoodRegion) NOT OUTSIDE M34Wide
  M34Check = (M34Wide AND OvpOnM34W) NOT INTERACT GoodVIA
  VIA_Check3 NOT OUTSIDE M34Check 
}    


//VIA4 CHECKS
//===========

VIA4.W.1 { @ Width (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA4 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA4.S.1 { @ Space >= 0.220 
  EXT VIA4 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA4.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA4Merge = SIZE VIA4 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA4Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA4Array = MinArray INTERACT VIA4 >= 3 * 3
  VIA4InArray = VIA4 INTERACT VIA4Array
  EXT VIA4InArray < 0.29 ABUT < 90 REGION
}
VIA4.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA4 M4 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA4.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA4 M4 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M4 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA4.R.1 is checked by VIA4.W.1

VIA4.R.2 { @ At least two VIAxs, with space <= 0.71 um, are required to connect Mx and Mx+1, if either Mx or Mx+1 has both width and length >1.4 um. If four VIAxs are used, the space must be <= 1 um.   
  M5OvpM4W = (M5 AND M4Wide1.4) OR (M4 AND M5Wide1.4)
  m4_has_wm_ovp = METAL4i INTERACT M5OvpM4W
  m5_has_wm_ovp = METAL5i INTERACT M5OvpM4W
  MOvp = m4_has_wm_ovp AND m5_has_wm_ovp 
  VIA_EXC = VIA4 NOT VIA_EXD
  M45Wide = M4Wide1.4 OR M5Wide1.4
  OvpOnM45W = MOvp NOT OUTSIDE M45Wide
  VIA_Check4 = VIA_EXC INTERACT OvpOnM45W 
  
  Merge1OnM45W = SIZE VIA_Check4 BY 0.71/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion1  = Merge1OnM45W INTERACT VIA_Check4 < 2
  GoodRegion1 = Merge1OnM45W OUTSIDE badRegion1
  Merge2OnM45W = SIZE Merge1OnM45W BY (1 - 0.71)/2 INSIDE OF OvpOnM45W STEP 0.21*0.7
  badRegion2  = Merge2OnM45W INTERACT VIA_Check4 < 4
  GoodRegion2 = Merge2OnM45W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check4 INTERACT GoodRegion) NOT OUTSIDE M45Wide
  M45Check = (M45Wide AND OvpOnM45W) NOT INTERACT GoodVIA
  VIA_Check4 NOT OUTSIDE M45Check 
}    

#IFDEF THICK_TOP3_METAL

//TOP VIA5 CHECKS
//================

VIA5.W.1.THICK { @ Width (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA5 == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA5.S.1.THICK { @ Space >= 0.35 
  EXT VIA5 < 0.35 ABUT < 90 SINGULAR REGION
}
VIA5.S.2.THICK { @ Space in VIA5 array [VIA5 number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIA5Merge = SIZE VIA5 BY 0.56 / 2 OVERUNDER  // space <= 0.56 um treated as array
  // ( ( 3 - 1 ) * 0.36 + ( 3 - 2 ) * 0.56 ) / 2 ) = 0.64
  MinArray = SIZE VIA5Merge BY 0.64 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA5Array = MinArray INTERACT VIA5 >= 3 * 3
  VIA5InArray = VIA5 INTERACT VIA5Array
  EXT VIA5InArray < 0.54 ABUT < 90 REGION
}
VIA5.EN.1.THICK { @ Enclosure by M5 >= 0.01
  ENC VIA5 M5 < 0.01 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA5.EN.2.THICK { @ Enclosure by M5 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT > 0 < 90 GOOD 0.01 0.05 OPPOSITE 0.01 0.05 OPPOSITE
  Y = ENC [X] M5 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.36 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA5.R.1 is checked by VIA5.W.1

VIA5.R.2.THICK { @ At least 2 VIA5, with space <=1.7um, are required to connect M5 and M6, 
	@ if either M5 or M6 has both width and length >1.8um. 
  M6OvpM5W = (M6 AND M5Wide1.8) OR (M5 AND M6Wide1.8)
  m5_has_wm_ovp = METAL5i INTERACT M6OvpM5W
  m6_has_wm_ovp = METAL6i INTERACT M6OvpM5W
  MOvp = m5_has_wm_ovp AND m6_has_wm_ovp 
  VIA_EXC = VIA5 NOT VIA_EXD
  M56Wide = M5Wide1.8 OR M6Wide1.8
  OvpOnM56W = MOvp NOT OUTSIDE M56Wide
  VIA_Check5 = VIA_EXC INTERACT OvpOnM56W 
  
  Merge1OnM56W = SIZE VIA_Check5 BY 1.7/2 INSIDE OF OvpOnM56W STEP 0.42*0.7
  badRegion1  = Merge1OnM56W INTERACT VIA_Check5 < 2
  GoodRegion1 = Merge1OnM56W OUTSIDE badRegion1
  GoodVIA5 = (VIA_Check5 INTERACT GoodRegion1) NOT OUTSIDE M56Wide
  M56Check = (M56Wide AND OvpOnM56W) NOT INTERACT GoodVIA5
  VIA_Check5 NOT OUTSIDE M56Check 
}    


#ELSE

//VIA5 CHECKS
//===========

VIA5.W.1 { @ Width (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA5 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA5.S.1 { @ Space >= 0.220 
  EXT VIA5 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA5.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA5Merge = SIZE VIA5 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA5Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA5Array = MinArray INTERACT VIA5 >= 3 * 3
  VIA5InArray = VIA5 INTERACT VIA5Array
  EXT VIA5InArray < 0.29 ABUT < 90 REGION
}
VIA5.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA5 M5 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA5.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M5 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA5.R.1 is checked by VIA5.W.1

VIA5.R.2 { @ At least two VIAxs, with space <= 0.71 um, are required to connect Mx and Mx+1, if either Mx or Mx+1 has both width and length >1.4 um. If four VIAxs are used, the space must be <= 1 um.   
  M6OvpM5W = (M6 AND M5Wide1.4) OR (M5 AND M6Wide1.4)
  m5_has_wm_ovp = METAL5i INTERACT M6OvpM5W
  m6_has_wm_ovp = METAL6i INTERACT M6OvpM5W
  MOvp = m5_has_wm_ovp AND m6_has_wm_ovp 
  VIA_EXC = VIA5 NOT VIA_EXD
  M56Wide = M5Wide1.4 OR M6Wide1.4
  OvpOnM56W = MOvp NOT OUTSIDE M56Wide
  VIA_Check5 = VIA_EXC INTERACT OvpOnM56W 
  
  Merge1OnM56W = SIZE VIA_Check5 BY 0.71/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion1  = Merge1OnM56W INTERACT VIA_Check5 < 2
  GoodRegion1 = Merge1OnM56W OUTSIDE badRegion1
  Merge2OnM56W = SIZE Merge1OnM56W BY (1 - 0.71)/2 INSIDE OF OvpOnM56W STEP 0.21*0.7
  badRegion2  = Merge2OnM56W INTERACT VIA_Check5 < 4
  GoodRegion2 = Merge2OnM56W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check5 INTERACT GoodRegion) NOT OUTSIDE M56Wide
  M56Check = (M56Wide AND OvpOnM56W) NOT INTERACT GoodVIA
  VIA_Check5 NOT OUTSIDE M56Check 
}    
#ENDIF

#IFDEF THICK_TOP2_METAL

//TOP VIA6 CHECKS
//================

VIA6.W.1.THICK { @ Width (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA6 == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA6.S.1.THICK { @ Space >= 0.35 
  EXT VIA6 < 0.35 ABUT < 90 SINGULAR REGION
}
VIA6.S.2.THICK { @ Space in VIA6 array [VIA6 number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIA6Merge = SIZE VIA6 BY 0.56 / 2 OVERUNDER  // space <= 0.56 um treated as array
  // ( ( 3 - 1 ) * 0.36 + ( 3 - 2 ) * 0.56 ) / 2 ) = 0.64
  MinArray = SIZE VIA6Merge BY 0.64 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < 0.54 ABUT < 90 REGION
}

#IFDEF THICK_TOP3_METAL

VIA6.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M6 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M6 < 0.09 ABUT < 90 SINGULAR REGION
}

#ELSE
VIA6.EN.1.THICK { @ Enclosure by M6 >= 0.01
  ENC VIA6 M6 < 0.01 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure by M6 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD 0.01 0.05 OPPOSITE 0.01 0.05 OPPOSITE
  Y = ENC [X] M6 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.36 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

// VIA6.R.1 is checked by VIA6.W.1

VIA6.R.2.THICK { @ At least 2 VIA6, with space <=1.7um, are required to connect M6 and M7, 
	@ if either M6 or M7 has both width and length >1.8um. 
  M7OvpM6W = (M7 AND M6Wide1.8) OR (M6 AND M7Wide1.8)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.8 OR M7Wide1.8
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 1.7/2 INSIDE OF OvpOnM67W STEP 0.42*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  GoodVIA6 = (VIA_Check6 INTERACT GoodRegion1) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA6
  VIA_Check6 NOT OUTSIDE M67Check 
}    


#ELSE
#IFDEF THICK_TOP3_METAL

//TOP VIA6 CHECKS
//================

VIA6.W.1.THICK { @ Width (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA6 == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA6.S.1.THICK { @ Space >= 0.35 
  EXT VIA6 < 0.35 ABUT < 90 SINGULAR REGION
}
VIA6.S.2.THICK { @ Space in VIA6 array [VIA6 number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIA6Merge = SIZE VIA6 BY 0.56 / 2 OVERUNDER  // space <= 0.56 um treated as array
  // ( ( 3 - 1 ) * 0.36 + ( 3 - 2 ) * 0.56 ) / 2 ) = 0.64
  MinArray = SIZE VIA6Merge BY 0.64 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < 0.54 ABUT < 90 REGION
}

#IFDEF THICK_TOP3_METAL

VIA6.EN.1.THICK { @ Enclosure of VIA6 >= 0.020 
  ENC VIA6 M6 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure of VIA6 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA6 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M6 < 0.09 ABUT < 90 SINGULAR REGION
}

#ELSE
VIA6.EN.1.THICK { @ Enclosure by M6 >= 0.01
  ENC VIA6 M6 < 0.01 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2.THICK { @ Enclosure by M6 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD 0.01 0.05 OPPOSITE 0.01 0.05 OPPOSITE
  Y = ENC [X] M6 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.36 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

// VIA6.R.1 is checked by VIA6.W.1

VIA6.R.2.THICK { @ At least 2 VIA6, with space <=1.7um, are required to connect M6 and M7, 
	@ if either M6 or M7 has both width and length >1.8um. 
  M7OvpM6W = (M7 AND M6Wide1.8) OR (M6 AND M7Wide1.8)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.8 OR M7Wide1.8
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 1.7/2 INSIDE OF OvpOnM67W STEP 0.42*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  GoodVIA6 = (VIA_Check6 INTERACT GoodRegion1) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA6
  VIA_Check6 NOT OUTSIDE M67Check 
}    


#ELSE

//VIA6 CHECKS
//===========

VIA6.W.1 { @ Width (maximum =minimum) = 0.190 
  A = NOT RECTANGLE VIA6 == 0.19 BY == 0.19 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA6.S.1 { @ Space >= 0.220 
  EXT VIA6 < 0.22 ABUT < 90 SINGULAR REGION
}
VIA6.S.2 { @ Space in VIAx array [VIAx number >= 3 X 3 (row and column >= 3) with space <= 0.31um] >= 0.290 
  VIA6Merge = SIZE VIA6 BY 0.31 / 2 OVERUNDER  // space <= 0.31 um treated as array
  // ( ( 3 - 1 ) * 0.19 + ( 3 - 2 ) * 0.31 ) / 2 ) = 0.345
  MinArray = SIZE VIA6Merge BY 0.345 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA6Array = MinArray INTERACT VIA6 >= 3 * 3
  VIA6InArray = VIA6 INTERACT VIA6Array
  EXT VIA6InArray < 0.29 ABUT < 90 REGION
}
VIA6.EN.1 { @ Enclosure by Mx >= 0.005 
  ENC VIA6 M6 < 0.005 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA6.EN.2 { @ Enclosure by Mx [at least two opposite sides] >= 0.050 
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT > 0 < 90 GOOD 0.005 0.05 OPPOSITE 0.005 0.05 OPPOSITE
  Y = ENC [X] M6 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.19 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// VIA6.R.1 is checked by VIA6.W.1

VIA6.R.2 { @ At least two VIAxs, with space <= 0.71 um, are required to connect Mx and Mx+1, if either Mx or Mx+1 has both width and length >1.4 um. If four VIAxs are used, the space must be <= 1 um.   
  M7OvpM6W = (M7 AND M6Wide1.4) OR (M6 AND M7Wide1.4)
  m6_has_wm_ovp = METAL6i INTERACT M7OvpM6W
  m7_has_wm_ovp = METAL7i INTERACT M7OvpM6W
  MOvp = m6_has_wm_ovp AND m7_has_wm_ovp 
  VIA_EXC = VIA6 NOT VIA_EXD
  M67Wide = M6Wide1.4 OR M7Wide1.4
  OvpOnM67W = MOvp NOT OUTSIDE M67Wide
  VIA_Check6 = VIA_EXC INTERACT OvpOnM67W 
  
  Merge1OnM67W = SIZE VIA_Check6 BY 0.71/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion1  = Merge1OnM67W INTERACT VIA_Check6 < 2
  GoodRegion1 = Merge1OnM67W OUTSIDE badRegion1
  Merge2OnM67W = SIZE Merge1OnM67W BY (1 - 0.71)/2 INSIDE OF OvpOnM67W STEP 0.21*0.7
  badRegion2  = Merge2OnM67W INTERACT VIA_Check6 < 4
  GoodRegion2 = Merge2OnM67W OUTSIDE badRegion2
  GoodRegion = GoodRegion1 OR GoodRegion2
  GoodVIA = (VIA_Check6 INTERACT GoodRegion) NOT OUTSIDE M67Wide
  M67Check = (M67Wide AND OvpOnM67W) NOT INTERACT GoodVIA
  VIA_Check6 NOT OUTSIDE M67Check 
}    
#ENDIF
#ENDIF



//TOP VIA7 CHECKS
//================

VIA7.W.1.THICK { @ Width (maximum = minimum) = 0.36 
  A = NOT RECTANGLE VIA7 == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA7.S.1.THICK { @ Space >= 0.35 
  EXT VIA7 < 0.35 ABUT < 90 SINGULAR REGION
}
VIA7.S.2.THICK { @ Space in VIA7 array [VIA7 number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIA7Merge = SIZE VIA7 BY 0.56 / 2 OVERUNDER  // space <= 0.56 um treated as array
  // ( ( 3 - 1 ) * 0.36 + ( 3 - 2 ) * 0.56 ) / 2 ) = 0.64
  MinArray = SIZE VIA7Merge BY 0.64 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIA7Array = MinArray INTERACT VIA7 >= 3 * 3
  VIA7InArray = VIA7 INTERACT VIA7Array
  EXT VIA7InArray < 0.54 ABUT < 90 REGION
}

#IFDEF THICK_TOP2_METAL

VIA7.EN.1.THICK { @ Enclosure of VIA7 >= 0.020
  ENC VIA7 M7 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure of VIA7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M7 < 0.09 ABUT < 90 SINGULAR REGION
}

#ELSE

#IFDEF THICK_TOP3_METAL

VIA7.EN.1.THICK { @ Enclosure of VIA7 >= 0.020 
  ENC VIA7 M7 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure of VIA7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M7 < 0.09 ABUT < 90 SINGULAR REGION
}

#ELSE
VIA7.EN.1.THICK { @ Enclosure by M7 >= 0.01
  ENC VIA7 M7 < 0.01 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIA7.EN.2.THICK { @ Enclosure by M7 (at least two opposite sides) >= 0.05
  X = RECTANGLE ENCLOSURE VIA7 M7 ABUT > 0 < 90 GOOD 0.01 0.05 OPPOSITE 0.01 0.05 OPPOSITE
  Y = ENC [X] M7 < 0.05 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.36 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF
#ENDIF

// VIA7.R.1 is checked by VIA7.W.1

VIA7.R.2.THICK { @ At least 2 VIA7, with space <=1.7um, are required to connect M7 and M8, 
	@ if either M7 or M8 has both width and length >1.8um. 
  M8OvpM7W = (M8 AND M7Wide1.8) OR (M7 AND M8Wide1.8)
  m7_has_wm_ovp = METAL7i INTERACT M8OvpM7W
  m8_has_wm_ovp = METAL8i INTERACT M8OvpM7W
  MOvp = m7_has_wm_ovp AND m8_has_wm_ovp 
  VIA_EXC = VIA7 NOT VIA_EXD
  M78Wide = M7Wide1.8 OR M8Wide1.8
  OvpOnM78W = MOvp NOT OUTSIDE M78Wide
  VIA_Check7 = VIA_EXC INTERACT OvpOnM78W 
  
  Merge1OnM78W = SIZE VIA_Check7 BY 1.7/2 INSIDE OF OvpOnM78W STEP 0.42*0.7
  badRegion1  = Merge1OnM78W INTERACT VIA_Check7 < 2
  GoodRegion1 = Merge1OnM78W OUTSIDE badRegion1
  GoodVIA7 = (VIA_Check7 INTERACT GoodRegion1) NOT OUTSIDE M78Wide
  M78Check = (M78Wide AND OvpOnM78W) NOT INTERACT GoodVIA7
  VIA_Check7 NOT OUTSIDE M78Check 
}    



//THICK M8 CHECKS
//=============


M8.W.1.THICK { @ Width >= 0.400 
  INT M8 < 0.4 ABUT < 90 SINGULAR REGION
}
M8.S.1.THICK { @ Space >= 0.420 
  EXT M8 < 0.42 ABUT < 90 SINGULAR REGION
}
M8.S.2.THICK { @ Space to wide Mx (both metal line width and length > 10 um), or wide Mx branch (a small piece of metal is connected to a wide metal) within a <= 1.0 um range from the wide Mx >= 0.600 
  M8_S5 = SHRINK (SHRINK (SHRINK (SHRINK M8Wide7 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M8_G5 = GROW (GROW (GROW (GROW M8_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M8_Wide = M8_G5 AND M8
  M8_Exp = SIZE M8_Wide BY 1 INSIDE OF M8 STEP 0.294
  M8_Branch = M8_Exp NOT M8_Wide
  M8_Branch_edge = M8_Branch COIN INSIDE EDGE M8
  M8_Check = M8 AND (SIZE M8_Exp BY 0.6)
  M8_Else = M8_Check NOT INTERACT M8_Exp
  M8_Extend = M8_Check NOT M8_Exp 
  M8_WideC = STAMP M8_Wide BY M8x
  M8_ElseC = STAMP M8_Check BY M8x
  EXT M8_WideC M8_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M8_Branch_edge M8_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT M8_Branch_edge M8_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT M8_Branch_edge M8_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT M8_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT M8_Extend
}
M8.EN.1.THICK { @ Enclosure of VIA7 >= 0.020 
  ENC VIA7 M8 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
M8.EN.2.THICK { @ Enclosure of VIA7 [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA7 for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIA7 M8 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M8 < 0.09 ABUT < 90 SINGULAR REGION
}
M8.A.1.THICK { @ Area >= 0.562 
  AREA M8 < 0.562
}
M8.A.2.THICK { @ Enclosed area >= 0.565 
  HOLES M8 < 0.565 INNER
}  



// VIAD CHECKS
//=============

VIAD.W.1 { @ VIAD.W.1 must be 0.36 x 0.36 
  A = NOT RECTANGLE VIAD == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIAD.S.1 { @ VIAD.S.1 spacing 0.35um 
  EXT VIAD < 0.35 ABUT < 90 SINGULAR REGION
}
VIAD.S.2 { @ Space in VIAD array [VIAD number >=3X3(raw and column >=3) with space <=0.56um] >= 0.54
  VIADMerge = SIZE VIAD BY 0.56 / 2 OVERUNDER  // space <= 0.56 um treated as array
  // ( ( 3 - 1 ) * 0.36 + ( 3 - 2 ) * 0.56 ) / 2 ) = 0.64
  MinArray = SIZE VIADMerge BY 0.64 UNDEROVER
  // get array larger than or equal to 3 x 3 
  VIADArray = MinArray INTERACT VIAD >= 3 * 3
  VIADInArray = VIAD INTERACT VIADArray
  EXT VIADInArray < 0.54 ABUT < 90 REGION
}

VIAD.EN.1 { @ Enclosure of VIAD >= 0.020
  ENC VIAD M8 < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR
}
VIAD.EN.2 { @ Enclosure of VIAD [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIAD for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIAD M8 ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A M8 < 0.09 ABUT < 90 SINGULAR REGION
}

MDWide1.8 = (SIZE MD BY 0.9 UNDEROVER TRUNCATE 0.9) AND MD

VIAD.R.2 { @ At least 2 VIAD, with space <=1.7um, are required to connect M8 and MD, 
	 @if either M8 or MD has both width and length >1.8um. 
  M9OvpM8W = (MD AND M8Wide1.8) OR (M8 AND MDWide1.8)
  m8_has_wm_ovp = METAL8i INTERACT M9OvpM8W
  m9_has_wm_ovp = MDi INTERACT M9OvpM8W
  MOvp = m8_has_wm_ovp AND m9_has_wm_ovp 
  VIA_EXC = VIAD NOT VIA_EXD
  M89Wide = M8Wide1.8 OR MDWide1.8
  OvpOnM89W = MOvp NOT OUTSIDE M89Wide
  VIAD_Check = VIA_EXC INTERACT OvpOnM89W 
  
  Merge1OnM89W = SIZE VIAD_Check BY 1.7/2 INSIDE OF OvpOnM89W STEP 0.42*0.7
  BadRegion1  = Merge1OnM89W INTERACT VIAD_Check < 2
  GoodRegion1 = Merge1OnM89W OUTSIDE BadRegion1
  GoodVIAD = (VIAD_Check INTERACT GoodRegion1) NOT OUTSIDE M89Wide
  M89Check = (M89Wide AND OvpOnM89W) NOT INTERACT GoodVIAD
  VIAD_Check NOT OUTSIDE M89Check
}
// MD CHECKS
//===========

MD.W.1 { @ Min. MD width 0.44 => 0.4 um 
  INT MD < 0.4 ABUT < 90 SINGULAR REGION
}
MD.S.1 { @ Min. MD spacing 0.46 => 0.42 um 
  EXT MD < 0.42 ABUT < 90 SINGULAR REGION
}
MD.S.2 { @ Min. MD wide metal rule 0.6um 
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MDWide1.8 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_Exp = SIZE MD_Wide BY 1 INSIDE OF MD STEP 0.294
  MD_Branch = MD_Exp NOT MD_Wide
  MD_Branch_edge = MD_Branch COIN INSIDE EDGE MD
  MD_Check = MD AND (SIZE MD_Exp BY 0.6)
  MD_Else = MD_Check NOT INTERACT MD_Exp
  MD_Extend = MD_Check NOT MD_Exp 
  MD_WideC = STAMP MD_Wide BY MDx
  MD_ElseC = STAMP MD_Check BY MDx
  EXT MD_WideC MD_ElseC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT MD_Branch_edge MD_Else < 0.6 ABUT >0 <89.5 OPPOSITE REGION
  EXT MD_Branch_edge MD_Else < 0.6 ABUT >0 <89.5 CORNER REGION
  EXT MD_Branch_edge MD_Else < 0.6 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT MD_Exp < 0.6 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT MD_Extend
}
MD.EN.1 { @ Enclosure of VIAD >= 0.020 
  ENC VIAD MD < 0.02 ABUT < 90 OUTSIDE ALSO SINGULAR REGION
}
MD.EN.2 { @ Enclosure of VIAD [at least two opposite sides] >= 0.11
	@ Or, Enclosure of VIA#- for all sides >= 0.09
  A = RECTANGLE ENCLOSURE VIAD MD ABUT > 0 < 90 GOOD 0.02 0.11 OPPOSITE 0.02 0.11 OPPOSITE
  ENC A MD < 0.09 ABUT < 90 SINGULAR REGION
}
MD.A.1 { @ Min. MD area region 0.562 
  AREA MD < 0.562
}
MD.A.2 { @ Min. MD enclosed area 0.565
  HOLES MD < 0.565 INNER
}

//METAL DENSITY RULES 
//===================


CHIPU10   = SIZE CHIP BY 10
CHIPU20   = SIZE CHIP BY 20
CHIPU30   = SIZE CHIP BY 30
CHIPU40   = SIZE CHIP BY 40
CHIPU50   = SIZE CHIP BY 50
CHIPU60   = SIZE CHIP BY 60
CHIPU70   = SIZE CHIP BY 70
CHIPU80   = SIZE CHIP BY 80
CHIPU90   = SIZE CHIP BY 90
#IFDEF FULL_CHIP
  METAL_DEN_EXC = (((FWi OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA
#ELSE
  METAL_DEN_EXC = ((FWi OR LMARK) OR LOGO) OR INDDMY
#ENDIF

CHIP_NOT_M_EXC = CHIP NOT METAL_DEN_EXC

M1_NOT_EXC      = ALL_M1 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM1EXCL= DM1EXCL NOT METAL_DEN_EXC
M1_AND_DM1EXCL  = ALL_M1 AND CHIP_AND_DM1EXCL

DM1.DN.2L { @ M1 local density range within DM1EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM1_DN_2L.density 
                         [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  AREA (ERR_WIN AND DM1EXCL) >= 10000			 
}
DM1.DN.2H { @ M1 local density range within DM1EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM1_DN_2H.density 
                         [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  AREA (ERR_WIN AND DM1EXCL) >= 10000			 
}
#ELSE

M1.DN.1L { @ {M1 OR DM1} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M1_DN_1L.density 
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M1.DN.1H { @ {M1 OR DM1} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M1_DN_1H.density 
          [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M1_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M1_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M2_NOT_EXC      = ALL_M2 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM2EXCL= DM2EXCL NOT METAL_DEN_EXC
M2_AND_DM2EXCL  = ALL_M2 AND CHIP_AND_DM2EXCL

DM2.DN.2L { @ M2 local density range within DM2EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM2_DN_2L.density 
                         [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  AREA (ERR_WIN AND DM2EXCL) >= 10000			 
}
DM2.DN.2H { @ M2 local density range within DM2EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM2_DN_2H.density 
                         [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  AREA (ERR_WIN AND DM2EXCL) >= 10000			 
}
#ELSE

M2.DN.1L { @ {M2 OR DM2} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M2_DN_1L.density 
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M2.DN.1H { @ {M2 OR DM2} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M2_DN_1H.density 
          [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M2_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M2_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M3_NOT_EXC      = ALL_M3 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM3EXCL= DM3EXCL NOT METAL_DEN_EXC
M3_AND_DM3EXCL  = ALL_M3 AND CHIP_AND_DM3EXCL

DM3.DN.2L { @ M3 local density range within DM3EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM3_DN_2L.density 
                         [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  AREA (ERR_WIN AND DM3EXCL) >= 10000			 
}
DM3.DN.2H { @ M3 local density range within DM3EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM3_DN_2H.density 
                         [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  AREA (ERR_WIN AND DM3EXCL) >= 10000			 
}
#ELSE

M3.DN.1L { @ {M3 OR DM3} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M3_DN_1L.density 
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M3.DN.1H { @ {M3 OR DM3} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M3_DN_1H.density 
          [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M3_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M3_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M4_NOT_EXC      = ALL_M4 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM4EXCL= DM4EXCL NOT METAL_DEN_EXC
M4_AND_DM4EXCL  = ALL_M4 AND CHIP_AND_DM4EXCL

DM4.DN.2L { @ M4 local density range within DM4EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM4_DN_2L.density 
                         [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  AREA (ERR_WIN AND DM4EXCL) >= 10000			 
}
DM4.DN.2H { @ M4 local density range within DM4EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM4_DN_2H.density 
                         [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  AREA (ERR_WIN AND DM4EXCL) >= 10000			 
}
#ELSE

M4.DN.1L { @ {M4 OR DM4} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M4_DN_1L.density 
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M4.DN.1H { @ {M4 OR DM4} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M4_DN_1H.density 
          [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M4_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M4_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M5_NOT_EXC      = ALL_M5 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM5EXCL= DM5EXCL NOT METAL_DEN_EXC
M5_AND_DM5EXCL  = ALL_M5 AND CHIP_AND_DM5EXCL

DM5.DN.2L { @ M5 local density range within DM5EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM5_DN_2L.density 
                         [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  AREA (ERR_WIN AND DM5EXCL) >= 10000			 
}
DM5.DN.2H { @ M5 local density range within DM5EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM5_DN_2H.density 
                         [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  AREA (ERR_WIN AND DM5EXCL) >= 10000			 
}
#ELSE

M5.DN.1L { @ {M5 OR DM5} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M5_DN_1L.density 
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M5.DN.1H { @ {M5 OR DM5} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M5_DN_1H.density 
          [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M5_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M5_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M6_NOT_EXC      = ALL_M6 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM6EXCL= DM6EXCL NOT METAL_DEN_EXC
M6_AND_DM6EXCL  = ALL_M6 AND CHIP_AND_DM6EXCL

DM6.DN.2L { @ M6 local density range within DM6EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM6_DN_2L.density 
                         [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  AREA (ERR_WIN AND DM6EXCL) >= 10000			 
}
DM6.DN.2H { @ M6 local density range within DM6EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM6_DN_2H.density 
                         [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  AREA (ERR_WIN AND DM6EXCL) >= 10000			 
}
#ELSE

M6.DN.1L { @ {M6 OR DM6} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M6_DN_1L.density 
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M6.DN.1H { @ {M6 OR DM6} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M6_DN_1H.density 
          [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M6_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M6_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


M7_NOT_EXC      = ALL_M7 NOT METAL_DEN_EXC

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM7EXCL= DM7EXCL NOT METAL_DEN_EXC
M7_AND_DM7EXCL  = ALL_M7 AND CHIP_AND_DM7EXCL

DM7.DN.2L { @ M7 local density range within DM7EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 15%
  ERR_WIN = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL < 0.15 WINDOW 200 STEP 100 BACKUP PRINT DM7_DN_2L.density 
                         [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  AREA (ERR_WIN AND DM7EXCL) >= 10000			 
}
DM7.DN.2H { @ M7 local density range within DM7EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM7_DN_2H.density 
                         [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  AREA (ERR_WIN AND DM7EXCL) >= 10000			 
}
#ELSE

M7.DN.1L { @ {M7 OR DM7} local density range over 200um x 200um area stepping 100um >= 15%
  D0 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP PRINT M7_DN_1L.density 
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D = RECTANGLE D0 == 200
  D0 NOT D
  D1 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D2 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D3 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D4 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D5 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D6 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D7 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D8 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D9 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC < 0.15 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
  D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}

M7.DN.1H { @ {M7 OR DM7} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M7_DN_1H.density 
          [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D2 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D3 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D4 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D5 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D6 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D7 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D8 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D9 = DENSITY M7_NOT_EXC CHIP_NOT_M_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M7_NOT_EXC)/AREA(CHIP_NOT_M_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF


METAL_DEN_EXC_TOP = (METAL_DEN_EXC OR PADi) OR PAD_EXD
M8_NOT_EXC        = ALL_M8 NOT METAL_DEN_EXC_TOP
CHIP_NOT_M8_EXC   = CHIP NOT METAL_DEN_EXC_TOP

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DM8EXCL = DM8EXCL NOT METAL_DEN_EXC_TOP
M8_AND_DM8EXCL = ALL_M8 AND CHIP_AND_DM8EXCL

DM8.DN.2L { @ M8 local density range within DM8EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 20%
  ERR_WIN = DENSITY M8_AND_DM8EXCL CHIP_AND_DM8EXCL < 0.2 WINDOW 200 STEP 100 BACKUP PRINT DM8_DN_2L.density 
                         [ AREA(M8_AND_DM8EXCL)/AREA(CHIP_AND_DM8EXCL) ]
  AREA (ERR_WIN AND DM8EXCL) >= 10000			 
}
DM8.DN.2H { @ M8 local density range within DM8EXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY M8_AND_DM8EXCL CHIP_AND_DM8EXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DM8_DN_2H.density 
                         [ AREA(M8_AND_DM8EXCL)/AREA(CHIP_AND_DM8EXCL) ]
  AREA (ERR_WIN AND DM8EXCL) >= 10000			 
}
#ELSE

M8.DN.1L { @ {M8 OR DM8} local density range over 200um x 200um area stepping 100um >= 20%
    D0 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP PRINT M8_DN_1L.density 
          [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D2 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D3 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D4 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D5 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D6 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D7 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D8 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D9 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
M8.DN.1H { @ {M8 OR DM8} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT M8_DN_1H.density 
          [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D2 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D3 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D4 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D5 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D6 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D7 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D8 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D9 = DENSITY M8_NOT_EXC CHIP_NOT_M8_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(M8_NOT_EXC)/AREA(CHIP_NOT_M8_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9) 
}
#ENDIF

//=========== MD Density Check ==================

METAL_DEN_EXC_MD = METAL_DEN_EXC OR UBM_EXDD
MD_NOT_EXC        = ALL_MD NOT METAL_DEN_EXC_MD
CHIP_RDL  = CHIP INTERACT MDi
CHIP_NOT_MD_EXC   = CHIP_RDL NOT METAL_DEN_EXC_MD

#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY

CHIP_AND_DMDEXCL = DMDEXCL NOT METAL_DEN_EXC_TOP
MD_AND_DMDEXCL = ALL_MD AND CHIP_AND_DMDEXCL

DMD.DN.2L { @ MD local density range within DMDEXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um >= 20%
  ERR_WIN = DENSITY MD_AND_DMDEXCL CHIP_AND_DMDEXCL < 0.2 WINDOW 200 STEP 100 BACKUP PRINT DMD_DN_2L.density 
                         [ AREA(MD_AND_DMDEXCL)/AREA(CHIP_AND_DMDEXCL) ]
  AREA (ERR_WIN AND DMDEXCL) >= 10000			 
}
DMD.DN.2H { @ MD local density range within DMDEXCL(overlapped area >= 10000um2) over 200um x 200um area stepping 100um <= 80%
  ERR_WIN = DENSITY MD_AND_DMDEXCL CHIP_AND_DMDEXCL > 0.8 WINDOW 200 STEP 100 BACKUP PRINT DMD_DN_2H.density 
                         [ AREA(MD_AND_DMDEXCL)/AREA(CHIP_AND_DMDEXCL) ]
  AREA (ERR_WIN AND DMDEXCL) >= 10000			 
}
#ELSE

MD.DN.1L { @ {MD OR DMD} local density range over 200um x 200um area stepping 100um >= 20%
    D0 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP PRINT MD_DN_1L.density 
          [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D2 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D3 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D4 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D5 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D6 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D7 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D8 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D9 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC < 0.2 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
MD.DN.1H { @ {MD OR DMD} local density range over 200um x 200um area stepping 100um <= 80%
    D0 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP PRINT MD_DN_1H.density 
          [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D = RECTANGLE D0 == 200
    D0 NOT D
    D1 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU10
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D2 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU20
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D3 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU30
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D4 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU40
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D5 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU50
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D6 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU60
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D7 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU70
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D8 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU80
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D9 = DENSITY MD_NOT_EXC CHIP_NOT_MD_EXC > 0.8 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER CHIPU90
            [ AREA(MD_NOT_EXC)/AREA(CHIP_NOT_MD_EXC) ]
    D INTERACT (((((((((D AND D1) AND D2) AND D3) AND D4) AND D5) AND D6) AND D7) AND D8) AND D9)
}
#ENDIF



// Antenna effect prevention rules are in the separated runset.


//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, poly, or metals (non-dummy patterns) >= 10 
  LOGO_OUTSIDE = (SIZE LOGO BY 10) NOT LOGO
  LOGO_OUTSIDE AND ODi
  LOGO_OUTSIDE AND POLYGi
  LOGO_OUTSIDE AND M1x
  LOGO_OUTSIDE AND M2x
  LOGO_OUTSIDE AND M3x
  LOGO_OUTSIDE AND M4x
  LOGO_OUTSIDE AND M5x
  LOGO_OUTSIDE AND M6x
  LOGO_OUTSIDE AND M7x
  LOGO_OUTSIDE AND M8x
  LOGO_OUTSIDE AND MDx
}
LOGO.R.1 { @ Overlap of EXCL, CB, CBD, AP, FW, PM, UBM, DOD, DPO, or DMx is not allowed.   
  EXCLi   AND LOGO
  PADi    AND LOGO	// CB
  CBDi    AND LOGO
  APi     AND LOGO
  FWi     AND LOGO
  PLMIDEi AND LOGO	// PM
  UBMi    AND LOGO
  DOD     AND LOGO
  DPO     AND LOGO
  DUM1    AND LOGO
  DUM2    AND LOGO
  DUM3    AND LOGO
  DUM4    AND LOGO
  DUM5    AND LOGO
  DUM6    AND LOGO
  DUM7    AND LOGO
  DUM8    AND LOGO
  DUMD    AND LOGO
}

// LOGO.R.2 is checked by LOGO.S.1




//CSR CHECKS
//==========

COL    = ENCLOSE RECTANGLE CONTi 0.005 200
SR_CO  = COL AND SR_M1   
SR_V1  = (VIA12i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V2  = (VIA23i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V3  = (VIA34i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V4  = (VIA45i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V5  = (VIA56i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V6  = (VIA67i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V7  = (VIA78i INTERACT SEALRING) NOT INTERACT PMDMY
SR_V8  = (VIA89i INTERACT SEALRING) NOT INTERACT PMDMY
SR_VD  = (VIADi INTERACT SEALRING) NOT INTERACT PMDMY 

CSR_OD = ODi AND CSRDMY
CC_M1  = M1x AND CSRDMY
CC_V1  = VIA12i AND CSRDMY
CC_M2  = M2x AND CSRDMY
CC_V2  = VIA23i AND CSRDMY
CC_M3  = M3x AND CSRDMY
CC_V3  = VIA34i AND CSRDMY
CC_M4  = M4x AND CSRDMY
CC_V4  = VIA45i AND CSRDMY
CC_M5  = M5x AND CSRDMY
CC_V5  = VIA56i AND CSRDMY
CC_M6  = M6x AND CSRDMY
CC_V6  = VIA67i AND CSRDMY
CC_M7  = M7x AND CSRDMY
CC_V7  = VIA78i AND CSRDMY
CC_M8  = M8x AND CSRDMY
CC_V8  = VIA89i AND CSRDMY
CC_M9  = M9x AND CSRDMY
CC_VD  = VIADi AND CSRDMY
CC_MD  = MDx AND CSRDMY

CSR_USER_GUIDE.1.M1 { @ METAL1 must be stacked and coincident the edge .
  XOR CC_M1 CC_M2 
}
CSR_USER_GUIDE.1.M2 { @ METAL2 must be stacked and coincident the edge .
  XOR CC_M2 CC_M3 
}
CSR_USER_GUIDE.1.M3 { @ METAL3 must be stacked and coincident the edge .
  XOR CC_M3 CC_M4 
}
CSR_USER_GUIDE.1.M4 { @ METAL4 must be stacked and coincident the edge .
  XOR CC_M4 CC_M5 
}
CSR_USER_GUIDE.1.M5 { @ METAL5 must be stacked and coincident the edge .
  XOR CC_M5 CC_M6 
}
CSR_USER_GUIDE.1.M6 { @ METAL6 must be stacked and coincident the edge .
  XOR CC_M6 CC_M7 
}
CSR_USER_GUIDE.1.M7 { @ METAL7 must be stacked and coincident the edge .
  XOR CC_M7 CC_M8 
}

CSR_USER_GUIDE.2.M1 { @ METAL1 at same level have a exact spacing value 1.5.
  CC_MH1 = HOLES CC_M1
  INT CC_MH1 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH1 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M2 { @ METAL2 at same level have a exact spacing value 1.5.
  CC_MH2 = HOLES CC_M2
  INT CC_MH2 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH2 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M3 { @ METAL3 at same level have a exact spacing value 1.5.
  CC_MH3 = HOLES CC_M3
  INT CC_MH3 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH3 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M4 { @ METAL4 at same level have a exact spacing value 1.5.
  CC_MH4 = HOLES CC_M4
  INT CC_MH4 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH4 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M5 { @ METAL5 at same level have a exact spacing value 1.5.
  CC_MH5 = HOLES CC_M5
  INT CC_MH5 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH5 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M6 { @ METAL6 at same level have a exact spacing value 1.5.
  CC_MH6 = HOLES CC_M6
  INT CC_MH6 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH6 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M7 { @ METAL7 at same level have a exact spacing value 1.5.
  CC_MH7 = HOLES CC_M7
  INT CC_MH7 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH7 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.M8 { @ METAL8 at same level have a exact spacing value 1.5.
  CC_MH8 = HOLES CC_M8
  INT CC_MH8 < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MH8 BY 0.75 UNDEROVER
}
CSR_USER_GUIDE.2.MD { @ MD at same level have a exact spacing value 1.5.
  CC_MHD = HOLES CC_MD
  INT CC_MHD < 1.5 ABUT < 90 PARALLEL ONLY
  SIZE CC_MHD BY 0.75 UNDEROVER
}

#IFDEF FULL_CHIP

CSR.R.1.DNWELLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DNWELLi
}  
CSR.R.1.NWELLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NWELLi
}  
CSR.R.1.DIFFi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DIFFi
}  
CSR.R.1.PDIFFi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PDIFFi
}  
CSR.R.1.NDIFFi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NDIFFi
}  
CSR.R.1.DOD { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DOD
}  
CSR.R.1.OD2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND OD2i
}  
CSR.R.1.POLYGi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND POLYGi
}  
CSR.R.1.DPO { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DPO
}  
CSR.R.1.PIMPi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PIMPi
}  
CSR.R.1.NIMPi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NIMPi
}  
CSR.R.1.CONTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CONTi
}  
CSR.R.1.METAL1i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL1i
}  
CSR.R.1.M1SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M1SLOTi
}  
CSR.R.1.DUM1 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM1
}  
CSR.R.1.METAL2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL2i
}  
CSR.R.1.M2SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M2SLOTi
}  
CSR.R.1.DUM2 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM2
}  
CSR.R.1.METAL3i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL3i
}  
CSR.R.1.M3SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M3SLOTi
}  
CSR.R.1.DUM3 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM3
}  
CSR.R.1.METAL4i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL4i
}  
CSR.R.1.M4SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M4SLOTi
}  
CSR.R.1.DUM4 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM4
}  
CSR.R.1.METAL5i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL5i
}  
CSR.R.1.M5SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M5SLOTi
}  
CSR.R.1.DUM5 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM5
}  
CSR.R.1.METAL6i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL6i
}  
CSR.R.1.M6SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M6SLOTi
}  
CSR.R.1.DUM6 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM6
}  
CSR.R.1.METAL7i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL7i
}  
CSR.R.1.M7SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M7SLOTi
}  
CSR.R.1.DUM7 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM7
}  
CSR.R.1.METAL8i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL8i
}  
CSR.R.1.M8SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M8SLOTi
}  
CSR.R.1.DUM8 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM8
}  
CSR.R.1.METAL9i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND METAL9i
}  
CSR.R.1.M9SLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND M9SLOTi
}  
CSR.R.1.DUM9 { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUM9
}  
CSR.R.1.MDi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND MDi
}  
CSR.R.1.MDSLOTi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND MDSLOTi
}  
CSR.R.1.DUMD { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DUMD
}  
CSR.R.1.VIA12i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA12i
}  
CSR.R.1.VIA23i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA23i
}  
CSR.R.1.VIA34i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA34i
}  
CSR.R.1.VIA45i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA45i
}  
CSR.R.1.VIA56i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA56i
}  
CSR.R.1.VIA67i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA67i
}  
CSR.R.1.VIA78i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA78i
}  
CSR.R.1.VIA89i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIA89i
}  
CSR.R.1.VIADi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VIADi
}  
CSR.R.1.APi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND APi
}  
CSR.R.1.PADi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PADi
}  
CSR.R.1.CB2i { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CB2i
}  
CSR.R.1.CBDi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CBDi
}  
CSR.R.1.UBMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND UBMi
}  
CSR.R.1.WBDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND WBDMY
}  
CSR.R.1.RPOi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RPOi
}  
CSR.R.1.NT_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NT_Ni
}  
CSR.R.1.VTL_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTL_Ni
}  
CSR.R.1.VTL_Pi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTL_Pi
}  
CSR.R.1.VTH_Ni { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTH_Ni
}  
CSR.R.1.VTH_Pi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VTH_Pi
}  
CSR.R.1.CTMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CTMi
}  
CSR.R.1.HRIi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HRIi
}  
CSR.R.1.FWi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND FWi
}  
CSR.R.1.PLMIDEi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PLMIDEi
}  
CSR.R.1.SEALRING { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SEALRING
}  
CSR.R.1.CSRDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CSRDMY
}  
CSR.R.1.NWDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND NWDMY
}  
CSR.R.1.HOTWL { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HOTWL
}  
CSR.R.1.RHDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RHDMY
}  
CSR.R.1.RPDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RPDMY
}  
CSR.R.1.PMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND PMDMY
}  
CSR.R.1.SDI { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SDI
}  
CSR.R.1.ESD1DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD1DMY
}  
CSR.R.1.ESD2DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD2DMY
}  
CSR.R.1.ESD3DMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND ESD3DMY
}  
CSR.R.1.LMARK { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND LMARK
}  
CSR.R.1.RHRIDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND RHRIDMY
}  
CSR.R.1.VARDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND VARDMY
}  
CSR.R.1.LOGO { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND LOGO
}  
CSR.R.1.INDDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND INDDMY
}  
CSR.R.1.CBMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CBMi
}  
CSR.R.1.CDUDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CDUDMY
}  
CSR.R.1.EXCLi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND EXCLi
}  
CSR.R.1.DMSRMi { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND DMSRMi
}  
CSR.R.1.HVTSRM { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND HVTSRM
}  
CSR.R.1.SRAMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND SRAMDMY
}  
CSR.R.1.CTMDMY { @ If customer requests TSMC to add CSR, seal ring and CDU, empty areas at 4 chip corners must be reserved and no layout is allowed inside.
  EMPTY_AREA AND CTMDMY
}  

#ENDIF

CSR.R.2 { @ User must add CSR in 4 chip corners.
  SR_EDGE NOT INTERACT CSRDMY	// Only dummy layer checked
}
CSR.R.3 { @ The CSR structure must include M8 (top metal)/ VIA7 (top via)/ M7/ VIA6VIA1/M1/CO/PP/OD layers. CSR is a fence type formed by crossed 1.5 um metals with CO/Via located at the metal crossing. Therefore, fully overlapped vias and metals of all levels (except top vias) are formed.   
  CSRDMY NOT INTERACT ODi 
  CSRDMY NOT INTERACT PIMPi 
  CSRDMY NOT INTERACT M1x 
  CSRDMY NOT INTERACT M2x 
  CSRDMY NOT INTERACT M3x 
  CSRDMY NOT INTERACT M4x 
  CSRDMY NOT INTERACT M5x 
  CSRDMY NOT INTERACT M6x 
  CSRDMY NOT INTERACT M7x 
  CSRDMY NOT INTERACT M8x 
  CSRDMY NOT ENCLOSE CONTi 
  CSRDMY NOT ENCLOSE VIA12i 
  CSRDMY NOT ENCLOSE VIA23i 
  CSRDMY NOT ENCLOSE VIA34i 
  CSRDMY NOT ENCLOSE VIA45i 
  CSRDMY NOT ENCLOSE VIA56i 
  CSRDMY NOT ENCLOSE VIA67i 
  CSRDMY NOT ENCLOSE VIA78i 
}
CSR.S.1 { @ CO space >= 0.320 
  CC_CO = CONTi AND CSRDMY
  EXT CC_CO < 0.32 ABUT < 90 SINGULAR  
}

// CSR.EN.1 is not able to check

CSR.S.2.VIA1 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V1 < 0.29 ABUT < 90 SINGULAR 
}
CSR.S.2.VIA2 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V2 < 0.29 ABUT < 90 SINGULAR 
}
CSR.S.2.VIA3 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V3 < 0.29 ABUT < 90 SINGULAR 
}
CSR.S.2.VIA4 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V4 < 0.29 ABUT < 90 SINGULAR 
}

#IFDEF THICK_TOP3_METAL

CSR.S.3.VIA5 { @ VIA7 space >= 0.360 
  EXT CC_V5 < 0.36 ABUT < 90 SINGULAR 
}

#ELSE

CSR.S.2.VIA5 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V5 < 0.29 ABUT < 90 SINGULAR 
}
#ENDIF 

#IFDEF THICK_TOP2_METAL

CSR.S.3.VIA6 { @ VIA7 space >= 0.360 
  EXT CC_V6 < 0.36 ABUT < 90 SINGULAR 
}

#ELSE

#IFDEF THICK_TOP3_METAL

CSR.S.3.VIA6 { @ VIA7 space >= 0.360 
  EXT CC_V6 < 0.36 ABUT < 90 SINGULAR 
}

#ELSE

CSR.S.2.VIA6 { @ VIA1~VIA6 space at the same level >= 0.290 
  EXT CC_V6 < 0.29 ABUT < 90 SINGULAR 
}
#ENDIF
#ENDIF 

CSR.S.3.VIA7 { @ VIA7 space >= 0.360 
  EXT CC_V7 < 0.36 ABUT < 90 SINGULAR 
}
CSR.S.3.VIAD { @ VIA7 space >= 0.360 
  EXT CC_VD < 0.36 ABUT < 90 SINGULAR 
}

// CSR.EN.2 is not able to check
// CSR.EN.3 is not able to check
// CSR.R.4 is not able to check


//SEAL-RING CHECKS
//================

SR_NOT_PMDMY = SEALRING NOT INTERACT PMDMY

SR_USER_GUIDE.0 { @ Seal-ring structure must be Mtop~M1/VIAtop~VIA1/CO/PP/OD
  SR_NOT_PMDMY NOT ODi 
  SR_NOT_PMDMY NOT PIMPi 
  SR_NOT_PMDMY NOT M1x 
  SR_NOT_PMDMY NOT M2x 
  SR_NOT_PMDMY NOT M3x 
  SR_NOT_PMDMY NOT M4x 
  SR_NOT_PMDMY NOT M5x 
  SR_NOT_PMDMY NOT M6x 
  SR_NOT_PMDMY NOT M7x 
  SR_NOT_PMDMY NOT M8x 
  SR_M1 NOT ENCLOSE CONTi 
  SR_M1 NOT ENCLOSE VIA12i 
  SR_M1 NOT ENCLOSE VIA23i 
  SR_M1 NOT ENCLOSE VIA34i 
  SR_M1 NOT ENCLOSE VIA45i 
  SR_M1 NOT ENCLOSE VIA56i 
  SR_M1 NOT ENCLOSE VIA67i 
  SR_M1 NOT ENCLOSE VIA78i 
}

SR_USER_GUIDE.1.M1 { @ Seal-ring exact space between M1 2.3um.
  EXT SR_M1 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M1 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M2 { @ Seal-ring exact space between M2 2.3um.
  EXT SR_M2 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M2 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M3 { @ Seal-ring exact space between M3 2.3um.
  EXT SR_M3 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M3 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M4 { @ Seal-ring exact space between M4 2.3um.
  EXT SR_M4 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M4 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M5 { @ Seal-ring exact space between M5 2.3um.
  EXT SR_M5 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M5 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M6 { @ Seal-ring exact space between M6 2.3um.
  EXT SR_M6 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M6 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M7 { @ Seal-ring exact space between M7 2.3um.
  EXT SR_M7 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M7 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.M8 { @ Seal-ring exact space between M8 2.3um.
  EXT SR_M8 < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_M8 BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}
SR_USER_GUIDE.1.MD { @ Seal-ring exact space between MD 2.3um.
  EXT SR_MD < 2.3 - 0.004 ABUT < 90 REGION SINGULAR 
  A = SIZE SR_MD BY 2.3 / 2 + 0.003
  SR_EDGE INTERACT A > 1
  B = HOLES A INNER 
  SR_EDGE INTERACT B > 1
}

SR_USER_GUIDE.3.CO { @ Seal-ring CO width respective 0.16.
  INT SR_CO < 0.16 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_CO BY 0.084 UNDEROVER
}

SR_USER_GUIDE.3.VIA1 { @ Seal-ring VIA1 width respective 0.13.
  INT SR_V1 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V1 BY 0.068 UNDEROVER
}
SR_USER_GUIDE.3.VIA2 { @ Seal-ring VIA2 width respective 0.13.
  INT SR_V2 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V2 BY 0.068 UNDEROVER
}
SR_USER_GUIDE.3.VIA3 { @ Seal-ring VIA3 width respective 0.13.
  INT SR_V3 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V3 BY 0.068 UNDEROVER
}
SR_USER_GUIDE.3.VIA4 { @ Seal-ring VIA4 width respective 0.13.
  INT SR_V4 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V4 BY 0.068 UNDEROVER
}

#IFDEF THICK_TOP3_METAL

SR_USER_GUIDE.3.VIA5 { @ Seal-ring VIA5 width respective 0.28 .
  INT SR_V5 < 0.28 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V5 BY 0.142 UNDEROVER
}

#ELSE

SR_USER_GUIDE.3.VIA5 { @ Seal-ring VIA5 width respective 0.13.
  INT SR_V5 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V5 BY 0.068 UNDEROVER
}
#ENDIF 

#IFDEF THICK_TOP2_METAL

SR_USER_GUIDE.3.VIA6 { @ Seal-ring VIA6 width respective 0.28 .
  INT SR_V6 < 0.28 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V6 BY 0.142 UNDEROVER
}

#ELSE


#IFDEF THICK_TOP3_METAL

SR_USER_GUIDE.3.VIA6 { @ Seal-ring VIA6 width respective 0.28 .
  INT SR_V6 < 0.28 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V6 BY 0.142 UNDEROVER
}

#ELSE

SR_USER_GUIDE.3.VIA6 { @ Seal-ring VIA6 width respective 0.13.
  INT SR_V6 < 0.13 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V6 BY 0.068 UNDEROVER
}
#ENDIF 
#ENDIF
SR_USER_GUIDE.3.VIA7 { @ Seal-ring VIA7 width respective 0.28 .
  INT SR_V7 < 0.28 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_V7 BY 0.142 UNDEROVER
}
SR_USER_GUIDE.3.VIAD { @ Seal-ring VIAD width respective 0.28 .
  INT SR_VD < 0.28 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_VD BY 0.142 UNDEROVER
}




//CDU CHECKS
//==========

CDU.R.1 { @ CDUDMY must be inside the assembly isolation, beside the seal ring.   
#IFDEF FULL_CHIP
  CDUDMY AND SCORE
  SR_EDGE NOT INTERACT CDUDMY		// Out most sealring structure
#ELSE
  COPY CDUDMY
#ENDIF
}

#IFDEF FULL_CHIP

CDU.R.2 { @ OD/Poly/CO/M1 must be inside the CDUDMY.   
  CDUDMY NOT INTERACT ODi
  CDUDMY NOT INTERACT POLYGi
  CDUDMY NOT INTERACT CONTi
  CDUDMY NOT INTERACT METAL1i
}

#ENDIF



//DUMMY OD RULE
//================

DOD.W.1 { @ Width >= 2.0 
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space >= 1.2 
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD [overlap is not allowed] >= 1.2 
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION
  ODi AND DOD
}
DOD.S.3 { @ Space to PO [overlap is not allowed] >= 1.2 
  EXT POLYGi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION 
   POLYGi AND DOD 
}
DOD.S.5 { @ Space to NW [overlap is not allowed] >= 0.6 
  EXT NWELLi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION
}
DOD.S.6 { @ Space to FW [overlap is not allowed] >= 1.2 
  EXT FWi DOD < DOD_S_6 ABUT < 90 SINGULAR REGION
  FWi AND DOD
}
DOD.S.7 { @ Space to LMARK [overlap is not allowed] >= 1.2 
  EXT LMARK DOD < DOD_S_7 ABUT < 90 SINGULAR REGION 
  LMARK AND DOD 
}
DOD.S.8 { @ Space to NWDMY [overlap is not allowed] >= 1.2 
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD 
}
DOD.S.9 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DOD
}
DOD.S.10 { @ Space to INDDMY [overlap is not allowed] >= 1.2 
  EXT INDDMY DOD < DOD_S_10 ABUT < 90 SINGULAR REGION 
  INDDMY AND DOD 
}
DOD.EN.1 { @ Enclosure by NW >= 0.6 
  ENC DOD NWELLi < DOD_EN_1 ABUT < 90 OVERLAP SINGULAR REGION
}

#IFDEF FULL_CHIP
DOD.EN.2 { @ Enclosure by chip edge >= 2.5 
  DOD NOT (SIZE CHIP_CHAMFERED BY -DOD_EN_2)
}
#ENDIF

// OD density rules are implemented in OD section


#IFDEF FULL_CHIP
DOD.R.1 { @ DOD is required. The DOD CAD layer (TSMC default, 6;1) must be different from the OD CAD layer.   
  CHIP_CHAMFERED NOT INTERACT DOD
}
#ENDIF

// DOD.R.2 is checked by CSR.R.1

DOD.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DOD
  NOT RECTANGLE DOD ORTHOGONAL ONLY
}


//DUMMY POLY RULE
//================

DPO.W.1 { @ Width >= 0.6 
  INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= 0.3 
  EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD [overlap is not allowed] >= 1.2 
  EXT ODi DPO < DPO_S_2 ABUT < 90 SINGULAR REGION 
  ODi AND DPO
}
DPO.S.3 { @ Space to PO [overlap is not allowed] >= 1.2 
  EXT POLYGi DPO < DPO_S_3 ABUT < 90 SINGULAR REGION 
  POLYGi AND DPO
}
DPO.S.5 { @ Space to FW [overlap is not allowed] >= 1.2 
  EXT FWi DPO < DPO_S_5 ABUT < 90 SINGULAR REGION 
  FWi AND DPO
}
DPO.S.6 { @ Space to LMARK [overlap is not allowed] >= 1.2 
  EXT LMARK DPO < DPO_S_6 ABUT < 90 SINGULAR REGION 
  LMARK AND DPO
}
DPO.S.7 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DPO
}
DPO.S.8 { @ Space to INDDMY [overlap is not allowed] >= 1.2 
  EXT INDDMY DPO < DPO_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DPO 
}
DPO.S.9 { @ Space to DOD [overlap is not allowed] >= 0.3 
  EXT DPO DOD < DPO_S_9 ABUT < 90 SINGULAR REGION
  DPO AND DOD
}  

#IFDEF FULL_CHIP
DPO.EN.1 { @ Enclosure by chip edge >= 2.5 
  DPO NOT (SIZE CHIP_CHAMFERED BY -DPO_EN_1)
}
#ENDIF

DPO.A.1 { @ Area >= 1.2 
  AREA DPO < 1.2
}  
// PO.DN.1 density rule is implemented in PO section

#IFDEF FULL_CHIP
DPO.R.1 { @ DPO is required [PO density of the whole chip <14%]. The DPO CAD layer (TSMC default, 17;1) must be a different layer from the PO CAD layer.   
  PO_DENSITY NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1

DPO.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DPO
  NOT RECTANGLE DPO ORTHOGONAL ONLY
}


//DUMMY METAL RULE
//=================

DM1.W.1 { @ Width (minimum) >= 0.4
  INT DUM1 < 0.4 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM1 BY 1.5 UNDEROVER
}
DM1.S.1 { @ Space >= 0.4
  EXT DUM1 < 0.4 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to M1 [overlap is not allowed] >= 0.6
  EXT M1x DUM1 < 0.6 ABUT < 90 SINGULAR REGION
  M1x AND DUM1
}
DM1.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM1 < 0.36 
}
DM1.A.2 { @ Area (maximum) <= 80
  AREA DUM1 > 80 
}

DM1.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM1 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM1
}
DM1.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM1 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM1
}
DM1.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM1
}
DM1.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM1 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM1
}

#IFDEF FULL_CHIP
DM1.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM1 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M1 section

#IFDEF FULL_CHIP
DM1.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM1
}
#ENDIF

// DM1.R.2 is checked by CSR.R.1

DM1.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM1
  NOT RECTANGLE DUM1 ORTHOGONAL ONLY
}

DM2.W.1 { @ Width (minimum) >= 0.4
  INT DUM2 < 0.4 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM2 BY 1.5 UNDEROVER
}
DM2.S.1 { @ Space >= 0.4
  EXT DUM2 < 0.4 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to M2 [overlap is not allowed] >= 0.6
  EXT M2x DUM2 < 0.6 ABUT < 90 SINGULAR REGION
  M2x AND DUM2
}
DM2.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM2 < 0.36 
}
DM2.A.2 { @ Area (maximum) <= 80
  AREA DUM2 > 80 
}

DM2.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM2 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM2
}
DM2.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM2 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM2
}
DM2.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM2
}
DM2.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM2 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM2
}

#IFDEF FULL_CHIP
DM2.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM2 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M2 section

#IFDEF FULL_CHIP
DM2.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM2
}
#ENDIF

// DM2.R.2 is checked by CSR.R.1

DM2.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM2
  NOT RECTANGLE DUM2 ORTHOGONAL ONLY
}

DM3.W.1 { @ Width (minimum) >= 0.4
  INT DUM3 < 0.4 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM3 BY 1.5 UNDEROVER
}
DM3.S.1 { @ Space >= 0.4
  EXT DUM3 < 0.4 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to M3 [overlap is not allowed] >= 0.6
  EXT M3x DUM3 < 0.6 ABUT < 90 SINGULAR REGION
  M3x AND DUM3
}
DM3.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM3 < 0.36 
}
DM3.A.2 { @ Area (maximum) <= 80
  AREA DUM3 > 80 
}

DM3.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM3 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM3
}
DM3.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM3 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM3
}
DM3.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM3
}
DM3.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM3 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM3
}

#IFDEF FULL_CHIP
DM3.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM3 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M3 section

#IFDEF FULL_CHIP
DM3.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM3
}
#ENDIF

// DM3.R.2 is checked by CSR.R.1

DM3.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM3
  NOT RECTANGLE DUM3 ORTHOGONAL ONLY
}

DM4.W.1 { @ Width (minimum) >= 0.4
  INT DUM4 < 0.4 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM4 BY 1.5 UNDEROVER
}
DM4.S.1 { @ Space >= 0.4
  EXT DUM4 < 0.4 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to M4 [overlap is not allowed] >= 0.6
  EXT M4x DUM4 < 0.6 ABUT < 90 SINGULAR REGION
  M4x AND DUM4
}
DM4.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM4 < 0.36 
}
DM4.A.2 { @ Area (maximum) <= 80
  AREA DUM4 > 80 
}

DM4.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM4 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM4
}
DM4.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM4 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM4
}
DM4.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM4
}
DM4.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM4 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM4
}

#IFDEF FULL_CHIP
DM4.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM4 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M4 section

#IFDEF FULL_CHIP
DM4.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM4
}
#ENDIF

// DM4.R.2 is checked by CSR.R.1

DM4.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM4
  NOT RECTANGLE DUM4 ORTHOGONAL ONLY
}

DM5.W.1 { @ Width (minimum) >= 0.4
  INT DUM5 < 0.4 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM5 BY 1.5 UNDEROVER
}
DM5.S.1 { @ Space >= 0.4
  EXT DUM5 < 0.4 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to M5 [overlap is not allowed] >= 0.6
  EXT M5x DUM5 < 0.6 ABUT < 90 SINGULAR REGION
  M5x AND DUM5
}
DM5.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM5 < 0.36 
}
DM5.A.2 { @ Area (maximum) <= 80
  AREA DUM5 > 80 
}

DM5.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM5 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM5
}
DM5.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM5 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM5
}
DM5.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM5
}
DM5.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM5 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM5
}

#IFDEF FULL_CHIP
DM5.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM5 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M5 section

#IFDEF FULL_CHIP
DM5.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM5
}
#ENDIF

// DM5.R.2 is checked by CSR.R.1

DM5.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM5
  NOT RECTANGLE DUM5 ORTHOGONAL ONLY
}


#IFDEF THICK_TOP3_METAL

DM6.W.1 { @ Width (minimum) >= 0.8
  INT DUM6 < 0.8 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY 1.5 UNDEROVER
}
DM6.S.1 { @ Space >= 0.8
  EXT DUM6 < 0.8 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to M6 [overlap is not allowed] >= 0.6
  EXT M6x DUM6 < 0.6 ABUT < 90 SINGULAR REGION
  M6x AND DUM6
}
DM6.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM6 < 0.8 
}
DM6.A.2 { @ Area (maximum) <= 160 
  AREA DUM6 > 160 
}

#ELSE

DM6.W.1 { @ Width (minimum) >= 0.4
  INT DUM6 < 0.4 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY 1.5 UNDEROVER
}
DM6.S.1 { @ Space >= 0.4
  EXT DUM6 < 0.4 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to M6 [overlap is not allowed] >= 0.6
  EXT M6x DUM6 < 0.6 ABUT < 90 SINGULAR REGION
  M6x AND DUM6
}
DM6.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM6 < 0.36 
}
DM6.A.2 { @ Area (maximum) <= 80
  AREA DUM6 > 80 
}
#ENDIF

DM6.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM6 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM6
}
DM6.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM6 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM6
}
DM6.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM6
}
DM6.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM6 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM6
}

#IFDEF FULL_CHIP
DM6.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM6 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M6 section

#IFDEF FULL_CHIP
DM6.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM6
}
#ENDIF

// DM6.R.2 is checked by CSR.R.1

DM6.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM6
  NOT RECTANGLE DUM6 ORTHOGONAL ONLY
}


#IFDEF THICK_TOP2_METAL

DM7.W.1 { @ Width (minimum) >= 0.8
  INT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.8
  EXT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.8
  AREA DUM7 < 0.8 
}
DM7.A.2 { @ Area (maximum) <= 160 
  AREA DUM7 > 160 
}

#ELSE


#IFDEF THICK_TOP3_METAL

DM7.W.1 { @ Width (minimum) >= 0.8
  INT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.8
  EXT DUM7 < 0.8 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM7 < 0.8 
}
DM7.A.2 { @ Area (maximum) <= 160 
  AREA DUM7 > 160 
}

#ELSE

DM7.W.1 { @ Width (minimum) >= 0.4
  INT DUM7 < 0.4 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM7 BY 1.5 UNDEROVER
}
DM7.S.1 { @ Space >= 0.4
  EXT DUM7 < 0.4 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to M7 [overlap is not allowed] >= 0.6
  EXT M7x DUM7 < 0.6 ABUT < 90 SINGULAR REGION
  M7x AND DUM7
}
DM7.A.1 { @ Area (minimum) >= 0.36 
  AREA DUM7 < 0.36 
}
DM7.A.2 { @ Area (maximum) <= 80
  AREA DUM7 > 80 
}
#ENDIF
#ENDIF

DM7.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM7 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM7
}
DM7.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM7 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM7
}
DM7.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM7
}
DM7.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM7 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM7
}

#IFDEF FULL_CHIP
DM7.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM7 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M7 section

#IFDEF FULL_CHIP
DM7.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM7
}
#ENDIF

// DM7.R.2 is checked by CSR.R.1

DM7.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM7
  NOT RECTANGLE DUM7 ORTHOGONAL ONLY
}

DM8.W.1 { @ Width (minimum) >= 0.8
  INT DUM8 < 0.8 ABUT < 90 SINGULAR REGION
}
DM8.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUM8 BY 1.5 UNDEROVER
}
DM8.S.1 { @ Space >= 0.8
  EXT DUM8 < 0.8 ABUT < 90 SINGULAR REGION
}
DM8.S.2 { @ Space to M8 [overlap is not allowed] >= 0.6
  EXT M8x DUM8 < 0.6 ABUT < 90 SINGULAR REGION
  M8x AND DUM8
}
DM8.A.1 { @ Area (minimum) >= 0.8 
  AREA DUM8 < 0.8 
}
DM8.A.2 { @ Area (maximum) <= 160 
  AREA DUM8 > 160 
}

DM8.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUM8 < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUM8
}
DM8.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUM8 < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUM8
}
DM8.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUM8
}
DM8.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUM8 < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM8
}

#IFDEF FULL_CHIP
DM8.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM8 NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in M8 section

#IFDEF FULL_CHIP
DM8.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  CHIP_CHAMFERED NOT INTERACT DUM8
}
#ENDIF

// DM8.R.2 is checked by CSR.R.1

DM8.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUM8
  NOT RECTANGLE DUM8 ORTHOGONAL ONLY
}

DMD.W.1 { @ Width (minimum) >= 0.8
  INT DUMD < 0.8 ABUT < 90 SINGULAR REGION
}
DMD.W.2 { @ Width (maximum) (by sizing down 1.5 um) <= 3.0 
  SIZE DUMD BY 1.5 UNDEROVER
}
DMD.S.1 { @ Space >= 0.8
  EXT DUMD < 0.8 ABUT < 90 SINGULAR REGION
}
DMD.S.2 { @ Space to MD [overlap is not allowed] >= 0.6
  EXT MDx DUMD < 0.6 ABUT < 90 SINGULAR REGION
  MDx AND DUMD
}
DMD.A.1 { @ Area (minimum) >= 0.8 
  AREA DUMD < 0.8 
}
DMD.A.2 { @ Area (maximum) <= 160 
  AREA DUMD > 160 
}

DMD.S.3 { @ Space to FW [overlap is not allowed] >= 5.0 
  EXT FWi DUMD < 5.0 ABUT < 90 SINGULAR REGION
  FWi AND DUMD
}
DMD.S.4 { @ Space to LMARK [overlap is not allowed] >= 5.0 
  EXT LMARK DUMD < 5.0 ABUT < 90 SINGULAR REGION 
  LMARK AND DUMD
}
DMD.S.6 { @ Space to LOGO [overlap is not allowed] >= 0.0 
  LOGO AND DUMD
}
DMD.S.7 { @ Space to INDDMY [overlap is not allowed] >= 18.0 
  EXT INDDMY DUMD < 18 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUMD
}

#IFDEF FULL_CHIP
DMD.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUMD NOT (SIZE CHIP_CHAMFERED BY -2.5)
}
#ENDIF

// Metal density rules are implemented in MD section

#IFDEF FULL_CHIP
DMD.R.1 { @ DMx is required. The DMx CAD layer (TSMC default, 31;1 for DM1) must be different from the Mx CAD layers.   
  (CHIP_CHAMFERED INTERACT MDx) NOT INTERACT DUMD
}
#ENDIF

// DMD.R.2 is checked by CSR.R.1

DMD.R.3 { @ The only shapes allowed are square (or rectangular) and solid. A 45-degree shape is not allowed.   
  HOLES DUMD
  NOT RECTANGLE DUMD ORTHOGONAL ONLY
}

DM7.S.8 { @ Space to CBM [CBM between Mx and Mx+1] [overlap is not allowed] >= 1.5 
  EXT CBM DUM7 < 1.5 ABUT < 90 SINGULAR REGION 
  CBM AND DUM7
}



//LAT CHECKS
//==========

PMOSi = PACTi INTERACT POLYGi
NMOSi = NACTi INTERACT POLYGi

// LUP.1 is not able to check

LUP.2 { @ For I/O buffers and ESD devices, space between each NMOS and PMOS. >= 15 
  EXT EPMOS ENMOS < 15 ABUT <90 >0 SINGULAR
}

CO_pact = CONTi OR (PSDi NOT OUTSIDE CONTi)
LUP.3P { @ For I/O and internal circuits, space from any point inside the source/drain OD area to the nearest pickup OD in the same N-well or P-well. <= 30 
  NPUi = NSTPi INTERACT CO_pact
  NSTPi_OS = SIZE NPUi BY 30 INSIDE OF NWELLi STEP 0.438 TRUNCATE 0.438
  PMOSi NOT NSTPi_OS
}

CO_nact = CONTi OR (NSDi NOT OUTSIDE CONTi)
LUP.3N { @ For I/O and internal circuits, space from any point inside the source/drain OD area to the nearest pickup OD in the same N-well or P-well. <= 30 
  PPUi = PSTPi INTERACT CO_nact
  PSTPi_OS = SIZE PPUi BY 30 INSIDE OF PWELi STEP 0.438 TRUNCATE 0.438
  NMOSi NOT PSTPi_OS
}

// LUP.4 is not able to check
// LUP.5 is not able to check
// LUP.6 is not able to check
// LUP.7 is not able to check
// LUP.8 is not able to check
// LUP.9 is not able to check
 


#IFDEF GUIDELINE

// I/O ESD Guidance
//==================

EPSD  = SDI  AND PASD
ENSD  = SDI  AND NASD
ED    = EPSD OR  ENSD
ECO = (CO AND SDI) AND OD
EGTE = SDI AND GATE
EGTE_W = GATE_W INSIDE EDGE SDI
EGTEN_W  = EGTE_W INSIDE EDGE NP
ENSD_NCO = (ENSD NOT INTERACT ECO) NOT INTERACT PSTP
ENSD_WCO = ENSD NOT ENSD_NCO
ENSD_SRC = ENSD_WCO OUTSIDE RPO

ESD1_GATE = EGTE AND ESD1DMY

ESD2_GATE = EGTE AND ESD2DMY
ESD2_REG_GATE = ESD2_GATE NOT INTERACT ENSD_NCO
ESD2_REG_GATE_W = ESD2_REG_GATE INSIDE EDGE OD

ESD2_TOL = (ENMOS AND ESD2DMY) INTERACT ENSD_NCO
ESD2_TOL_GATE = ESD2_GATE INTERACT ENSD_NCO
ESD2_TOL_GATE1 = ESD2_TOL_GATE NOT INTERACT ENSD_SRC
ESD2_TOL_GATE2 = ESD2_TOL_GATE INTERACT ENSD_SRC 
ESD2_TOL_GATE2_W = ESD2_TOL_GATE2 INSIDE EDGE OD

ERPO = RPO AND SDI
RPO0 = (ERPO OUTSIDE ESD1DMY) OUTSIDE ESD2DMY
EGTE0 = (EGTE OUTSIDE ESD1DMY) OUTSIDE ESD2DMY

HEGT = EGTE AND OD2
LEGT = EGTE NOT OD2
HEGN = HEGT AND NP
HEGP = HEGT AND PP


ESD.0 { @ CO can't inserted between gate and RPO for 1.0V, 1.2V NMOS and all PMOS I/O pattern 
  RED  = ED INTERACT RPO0
  XRPO = RED NOT RPO0
  XRPG = XRPO TOUCH EGTE0
  XRPG INTERACT ECO
}

// ESD.1 is not able to check

ESD.2 { @ Unit finger width of NMOS and PMOS for I/O buffer and Vdd to Vss protection. 20 - 60um
  PATH LENGTH EGTE_W < 20
  PATH LENGTH EGTE_W > 60
}

// ESD.3 is not able to check
// ESD.4 is not able to check
// ESD.5 is not able to check
// ESD.6 is not able to check
// ESD.7 is not able to check
// ESD.8 is not able to check

#IFDEF 3.3V
VARIABLE HighVoltage 3.3
VARIABLE WiESDVdd 0.35
VARIABLE WiESD1st 0.37
VARIABLE WiESD2nd 0.35
VARIABLE WoESD 0.4
#ENDIF

#IFDEF 2.5V
VARIABLE HighVoltage 2.5
VARIABLE WiESDVdd 0.33
VARIABLE WiESD1st 0.35
VARIABLE WiESD2nd 0.33
VARIABLE WoESD 0.33
#ENDIF

#IFDEF 1.8V
VARIABLE HighVoltage 1.8
VARIABLE WiESDVdd 0.20
VARIABLE WiESD1st 0.20
VARIABLE WiESD2nd 0.33
VARIABLE WoESD 0.20
#ENDIF

ESD.9A { @ ^HighVoltage V NMOS for VDD/VSS protection gate length < ^WiESDVdd um
  HEGN1 = HEGN AND ESD1DMY
  INT HEGN1 < WiESDVdd ABUT < 90 SINGULAR REGION
}
ESD.9B { @ 1.0V, 1.2V NMOS for VDD/VSS protection gate length < 0.18 um
  LEGN = LEGT AND NP
  LEGN1 = LEGN AND ESD1DMY
  INT LEGN1 < 0.18 ABUT < 90 SINGULAR REGION
}
ESD.9C { @ Min. length of 1st gate of ^HighVoltage V NMOS for HV tolerant I/O (with ESD implant) is ^WiESD1st um
  HEGN5 = ESD2_TOL_GATE1 INTERACT ESD3DMY
  INT HEGN5 < WiESD1st ABUT < 90 SINGULAR REGION
}
ESD.9D { @ Min. length of 2nd gate of ^HighVoltage V NMOS for HV tolerant I/O (with ESD implant) is ^WiESD2nd um
  HEGN6 = ESD2_TOL_GATE2 INTERACT ESD3DMY
  INT HEGN6 < WiESD2nd ABUT < 90 SINGULAR REGION
}
ESD.9E { @ ^HighVoltage V IO ESD NMOS (without ESD implant) gate length < ^WoESD um
  A = HEGN NOT INTERACT ESD3DMY
  HEGN2 = A NOT ESD1DMY
  INT HEGN2 < WoESD ABUT < 90 SINGULAR REGION
}
ESD.9F { @ ^HighVoltage V IO ESD PMOS gate length < 0.3 um
  INT HEGP < 0.3 ABUT < 90 SINGULAR REGION
}
ESD.9G { @ 1.0V, 1.2V IO ESD NMOS/PMOS gate length < 0.18 um
  INT LEGT < 0.18 ABUT < 90 SINGULAR REGION
}

// ESD.10 is not able to check
// ESD.11 is not able to check
// ESD.12 is not able to check
// ESD.13 is not able to check
// ESD.14 is not able to check
// ESD.15 is not able to check

ESD.16 { @ for 1.0V, 1.2V I/O, min. RPO space to poly in NMOS is 0.45um
	 @ for all PMOS, min. RPO space to poly is 0.45um
  EXT RPO0 EGTE0 < 0.45 ABUT < 90 SINGULAR REGION
}
ESD.17 { @ For 3.3V or 2.5V I/O, RPO on the drain side of NMOS region needs to overlap the poly gate by 0.06um
  X = ESD2_REG_GATE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY 0.06
  (ESD2_REG_GATE AND RPO) XOR Y
}
ESD.18A { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS
	  @ RPO needs to complete cover all inactive gates
  ESD2_TOL_GATE1 NOT RPO
}
ESD.18B { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS
	  @ RPO needs to overlap second poly gate by 0.06um
  ESD2_TOL_GATE2 OUTSIDE RPO
  X = ESD2_TOL_GATE NOT RPO
  ESD2_TOL NOT INTERACT X
  Y = ESD2_TOL_GATE2_W INSIDE EDGE RPO
  Z = EXPAND EDGE Y INSIDE BY 0.06
  (ESD2_TOL_GATE2 AND RPO) XOR Z
}
ESD.18C { @ For high voltage tolerant I/O design by 3.3V or 2.5V NMOS 
	  @ the 1st poly gate space to 2st poly gate == 0.25um
  X = ENSD_NCO INTERACT ESD2DMY
  INT X < 0.25 ABUT < 90 REGION
  SIZE X BY 0.125 UNDEROVER
}

// ESD.19 is checked by ESD.16

ESD.20 { @ For grounded gate ESD protection device between Vdd/Vss, the RPO should fully cover source/drain and the poly gate on top of channel.
  ESD1_GATE NOT RPO	 
}

// ESD.21 is not able to check

ESD.22 { @ I/O Min. RPO width on drain side & RPO edge to OD edge for 3.3V or 2.5V NMOS is 1.95 um
  X = (ENSD_WCO AND ESD2DMY) AND RPO
  INT X < 1.95 ABUT < 90 REGION
}
ESD.23 { @ For 1.0V, 1.2V NMOS or 1.0V, 1.2V/3.3V or 2.5V PMOS 
         @ min. width of RPO on drain side and RPO edge to OD edge 1.5um
  X = RPO0 AND ED
  INT X < 1.5 ABUT < 90 REGION
}
ESD.24 { @ ESD1DMY is for NMOS only / ESD2DMY is for 3.3V or 2.5V NMOS only
  ESD1DMY AND GATE_PP
  ESD2DMY AND GATE_PP
  ESD2DMY AND (GATE_NP NOT OD2)
}
ESD.25 { @ Min. extension of ESD3DMY over OD 0.1 um
  ENC OD ESD3DMY < 0.1 SINGULAR REGION
}
ESD.26 { @ Min. space between CO on source side to poly gate 0.75um
  EXT ECO EGTEN_W < 0.75 ABUT < 90 OPPOSITE REGION
}

// ESD.27 is not able to check
// ESD.28 is not able to check
// ESD.29 is not able to check
// ESD.30 is not able to check
// ESD.31 is not able to check
// ESD.32 is not able to check
// ESD.33 is not able to check
// ESD.34 is not able to check
// ESD.35 is not able to check
// ESD.36 is not able to check
// ESD.37 is not able to check

#ENDIF


#IFDEF SUGGESTED

SUGGESTED.EXCL_DMSRM { @ Boundary of overlapped EXCL and DMSRM layers must be aligned 
  A = EXCLi NOT OUTSIDE DMSRMi
  B = DMSRMi NOT OUTSIDE EXCLi
  A XOR B
} 

SUGGESTED.EXCL_SRM.NW { @ Spacing between NW along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.62 + 0.005)
  B = SIZE EXCL_SRM BY -(0.62 + 0.005)
  C = A NOT B
  D = NWELLi NOT OUTSIDE C
  E = EXT D < 0.62 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.OD { @ Spacing between OD along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.21 + 0.005)
  B = SIZE EXCL_SRM BY -(0.21 + 0.005)
  C = A NOT B
  D = ODi NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.PO { @ Spacing between POLY along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.13 + 0.005)
  B = SIZE EXCL_SRM BY -(0.13 + 0.005)
  C = A NOT B
  D = POLYGi NOT OUTSIDE C
  E = EXT D < 0.13 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.NP { @ Spacing between NP along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.31 + 0.005)
  B = SIZE EXCL_SRM BY -(0.31 + 0.005)
  C = A NOT B
  D = NIMPi NOT OUTSIDE C
  E = EXT D < 0.31 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.PP { @ Spacing between PP along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.31 + 0.005)
  B = SIZE EXCL_SRM BY -(0.31 + 0.005)
  C = A NOT B
  D = PIMPi NOT OUTSIDE C
  E = EXT D < 0.31 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.CO { @ Spacing between CO along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.18 + 0.005)
  B = SIZE EXCL_SRM BY -(0.18 + 0.005)
  C = A NOT B
  D = CONTi NOT OUTSIDE C
  E = EXT D < 0.18 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.M1 { @ Spacing between M1 along the boundary of EXCL, DMSRM, and SRAMDMY
  A = SIZE EXCL_SRM BY (0.18 + 0.005)
  B = SIZE EXCL_SRM BY -(0.18 + 0.005)
  C = A NOT B
  D = M1x NOT OUTSIDE C
  E = EXT D < 0.18 ABUT < 90 SINGULAR REGION
  E CUT EXCL_SRM
  E TOUCH EXCL_SRM
}

SUGGESTED.EXCL_SRM.VIA1 { @ Spacing between VIA1 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA12i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M2 { @ Spacing between M2 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M2x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA2 { @ Spacing between VIA2 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA23i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M3 { @ Spacing between M3 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M3x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA3 { @ Spacing between VIA3 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA34i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M4 { @ Spacing between M4 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M4x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA4 { @ Spacing between VIA4 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA45i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M5 { @ Spacing between M5 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M5x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA5 { @ Spacing between VIA5 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA56i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M6 { @ Spacing between M6 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M6x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA6 { @ Spacing between VIA6 along the boundary of EXCL
  A = SIZE EXCL BY (0.22 + 0.005)
  B = SIZE EXCL BY -(0.22 + 0.005)
  C = A NOT B
  D = VIA67i NOT OUTSIDE C
  E = EXT D < 0.22 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M7 { @ Spacing between M7 along the boundary of EXCL
  A = SIZE EXCL BY (0.21 + 0.005)
  B = SIZE EXCL BY -(0.21 + 0.005)
  C = A NOT B
  D = M7x NOT OUTSIDE C
  E = EXT D < 0.21 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.VIA7 { @ Spacing between VIA7 along the boundary of EXCL
  A = SIZE EXCL BY (0.35 + 0.005)
  B = SIZE EXCL BY -(0.35 + 0.005)
  C = A NOT B
  D = VIA78i NOT OUTSIDE C
  E = EXT D < 0.35 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}

SUGGESTED.EXCL_SRM.M8 { @ Spacing between M8 along the boundary of EXCL
  A = SIZE EXCL BY (0.42 + 0.005)
  B = SIZE EXCL BY -(0.42 + 0.005)
  C = A NOT B
  D = M8x NOT OUTSIDE C
  E = EXT D < 0.42 ABUT < 90 SINGULAR REGION
  E CUT EXCL
  E TOUCH EXCL
}


OD_NO_IMP = (((OD NOT ODWR) NOT LOGO) NOT CDUDMY) NOT IMP

SUGGESTED.OD.IMP { @ OD without IMP
  COPY OD_NO_IMP
}

SUGGESTED.OD.NW { @ OD straddle on NW without IMP
  OD_NO_IMP CUT NONWR
//  ENC OD_NO_IMP NONWR < 0.24 ABUT < 90 OVERLAP SINGULAR REGION
//  EXT NONWR OD_NO_IMP < 0.24 ABUT < 90 SINGULAR REGION
}

SUGGESTED.SDI_RHDMY { @ SDI should be for ESD devices only 
  SDI AND RHDMY
}

SUGGESTED.SDI_RPDMY { @ SDI should be for ESD devices only 
  SDI AND RPDMY
}

SUGGESTED.MS.M1 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M1HoleD NOT INTERACT (SIZE M1HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M2 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M2HoleD NOT INTERACT (SIZE M2HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M3 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M3HoleD NOT INTERACT (SIZE M3HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M4 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M4HoleD NOT INTERACT (SIZE M4HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M5 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M5HoleD NOT INTERACT (SIZE M5HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M6 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M6HoleD NOT INTERACT (SIZE M6HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M7 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M7HoleD NOT INTERACT (SIZE M7HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}
SUGGESTED.MS.M8 { @ Avoid long (>200um) and narrow (<3um) slots
  X = M8HoleD NOT INTERACT (SIZE M8HoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}

SUGGESTED.MS.MD { @ Avoid long (>200um) and narrow (<3um) slots
  X = MDHoleD NOT INTERACT (SIZE MDHoleD BY -1.499)
  A = LENGTH X > 3
  L = PATH LENGTH A > 200
  X WITH EDGE L
}

#ENDIF



// For TSMC's internal use only
GROUP SINGLE_VIA VIA?.R.2?
//DRC UNSELECT CHECK SINGLE_VIA 
#IFDEF CHECK_DENSITY_IN_DMxEXCL_ONLY
GROUP DENSITY_DRC OD.DN.? PO.DN.? DM?.DN.?
#ELSE
GROUP DENSITY_DRC OD.DN.? PO.DN.? M?.DN.? 
#ENDIF
//DRC UNSELECT CHECK DENSITY_DRC  
